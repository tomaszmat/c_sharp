
C:\Users\bluemann\Desktop\New Folder (2)\home_base3\TrueSTUDIO\home_base3\Debug\home_base3.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000013c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001fc0  0800013c  0800013c  0001013c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000000b8  080020fc  080020fc  000120fc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  080021b4  080021b4  000121b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  080021b8  080021b8  000121b8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000008  20000000  080021bc  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000118  20000008  080021c4  00020008  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  20000120  080021c4  00020120  2**0
                  ALLOC
  8 .ARM.attributes 00000029  00000000  00000000  00020008  2**0
                  CONTENTS, READONLY
  9 .debug_line   000059eb  00000000  00000000  00020031  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000e22e  00000000  00000000  00025a1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000025a1  00000000  00000000  00033c4a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000a08  00000000  00000000  000361f0  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000cd8  00000000  00000000  00036bf8  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000308b  00000000  00000000  000378d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .comment      0000007e  00000000  00000000  0003a95b  2**0
                  CONTENTS, READONLY
 16 .debug_frame  00001b4c  00000000  00000000  0003a9dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    00006e0a  00000000  00000000  0003c528  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0800013c <__do_global_dtors_aux>:
 800013c:	b510      	push	{r4, lr}
 800013e:	4c05      	ldr	r4, [pc, #20]	; (8000154 <__do_global_dtors_aux+0x18>)
 8000140:	7823      	ldrb	r3, [r4, #0]
 8000142:	b933      	cbnz	r3, 8000152 <__do_global_dtors_aux+0x16>
 8000144:	4b04      	ldr	r3, [pc, #16]	; (8000158 <__do_global_dtors_aux+0x1c>)
 8000146:	b113      	cbz	r3, 800014e <__do_global_dtors_aux+0x12>
 8000148:	4804      	ldr	r0, [pc, #16]	; (800015c <__do_global_dtors_aux+0x20>)
 800014a:	f3af 8000 	nop.w
 800014e:	2301      	movs	r3, #1
 8000150:	7023      	strb	r3, [r4, #0]
 8000152:	bd10      	pop	{r4, pc}
 8000154:	20000008 	.word	0x20000008
 8000158:	00000000 	.word	0x00000000
 800015c:	080020e4 	.word	0x080020e4

08000160 <frame_dummy>:
 8000160:	b508      	push	{r3, lr}
 8000162:	4b03      	ldr	r3, [pc, #12]	; (8000170 <frame_dummy+0x10>)
 8000164:	b11b      	cbz	r3, 800016e <frame_dummy+0xe>
 8000166:	4903      	ldr	r1, [pc, #12]	; (8000174 <frame_dummy+0x14>)
 8000168:	4803      	ldr	r0, [pc, #12]	; (8000178 <frame_dummy+0x18>)
 800016a:	f3af 8000 	nop.w
 800016e:	bd08      	pop	{r3, pc}
 8000170:	00000000 	.word	0x00000000
 8000174:	2000000c 	.word	0x2000000c
 8000178:	080020e4 	.word	0x080020e4

0800017c <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 800017c:	2100      	movs	r1, #0
  b LoopCopyDataInit
 800017e:	e003      	b.n	8000188 <LoopCopyDataInit>

08000180 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 8000180:	4b0b      	ldr	r3, [pc, #44]	; (80001b0 <LoopFillZerobss+0x14>)
  ldr r3, [r3, r1]
 8000182:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 8000184:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 8000186:	3104      	adds	r1, #4

08000188 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 8000188:	480a      	ldr	r0, [pc, #40]	; (80001b4 <LoopFillZerobss+0x18>)
  ldr r3, =_edata
 800018a:	4b0b      	ldr	r3, [pc, #44]	; (80001b8 <LoopFillZerobss+0x1c>)
  adds r2, r0, r1
 800018c:	1842      	adds	r2, r0, r1
  cmp r2, r3
 800018e:	429a      	cmp	r2, r3
  bcc CopyDataInit
 8000190:	d3f6      	bcc.n	8000180 <CopyDataInit>
  ldr r2, =_sbss
 8000192:	4a0a      	ldr	r2, [pc, #40]	; (80001bc <LoopFillZerobss+0x20>)
  b LoopFillZerobss
 8000194:	e002      	b.n	800019c <LoopFillZerobss>

08000196 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 8000196:	2300      	movs	r3, #0
  str r3, [r2], #4
 8000198:	f842 3b04 	str.w	r3, [r2], #4

0800019c <LoopFillZerobss>:

LoopFillZerobss:
  ldr r3, = _ebss
 800019c:	4b08      	ldr	r3, [pc, #32]	; (80001c0 <LoopFillZerobss+0x24>)
  cmp r2, r3
 800019e:	429a      	cmp	r2, r3
  bcc FillZerobss
 80001a0:	d3f9      	bcc.n	8000196 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 80001a2:	f000 fa05 	bl	80005b0 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80001a6:	f001 ff77 	bl	8002098 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80001aa:	f000 f897 	bl	80002dc <main>
  bx lr
 80001ae:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
  b LoopCopyDataInit

CopyDataInit:
  ldr r3, =_sidata
 80001b0:	080021bc 	.word	0x080021bc
  ldr r3, [r3, r1]
  str r3, [r0, r1]
  adds r1, r1, #4

LoopCopyDataInit:
  ldr r0, =_sdata
 80001b4:	20000000 	.word	0x20000000
  ldr r3, =_edata
 80001b8:	20000008 	.word	0x20000008
  adds r2, r0, r1
  cmp r2, r3
  bcc CopyDataInit
  ldr r2, =_sbss
 80001bc:	20000008 	.word	0x20000008
FillZerobss:
  movs r3, #0
  str r3, [r2], #4

LoopFillZerobss:
  ldr r3, = _ebss
 80001c0:	20000120 	.word	0x20000120

080001c4 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80001c4:	e7fe      	b.n	80001c4 <ADC1_IRQHandler>
	...

080001c8 <MX_GPIO_Init>:
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80001c8:	4b24      	ldr	r3, [pc, #144]	; (800025c <MX_GPIO_Init+0x94>)
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 80001ca:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80001cc:	69da      	ldr	r2, [r3, #28]
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 80001ce:	b089      	sub	sp, #36	; 0x24

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80001d0:	f042 0201 	orr.w	r2, r2, #1
 80001d4:	61da      	str	r2, [r3, #28]
 80001d6:	69da      	ldr	r2, [r3, #28]
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(rf_nss_GPIO_Port, rf_nss_Pin, GPIO_PIN_RESET);
 80001d8:	4f21      	ldr	r7, [pc, #132]	; (8000260 <MX_GPIO_Init+0x98>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80001da:	f002 0201 	and.w	r2, r2, #1
 80001de:	9200      	str	r2, [sp, #0]
 80001e0:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80001e2:	69da      	ldr	r2, [r3, #28]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(rf_nss_GPIO_Port, rf_nss_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(rf_ce_GPIO_Port, rf_ce_Pin, GPIO_PIN_RESET);
 80001e4:	4d1f      	ldr	r5, [pc, #124]	; (8000264 <MX_GPIO_Init+0x9c>)

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80001e6:	f042 0202 	orr.w	r2, r2, #2
 80001ea:	61da      	str	r2, [r3, #28]
 80001ec:	69da      	ldr	r2, [r3, #28]
  __HAL_RCC_GPIOC_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(rf_nss_GPIO_Port, rf_nss_Pin, GPIO_PIN_RESET);
 80001ee:	4638      	mov	r0, r7

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80001f0:	f002 0202 	and.w	r2, r2, #2
 80001f4:	9201      	str	r2, [sp, #4]
 80001f6:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80001f8:	69da      	ldr	r2, [r3, #28]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(rf_nss_GPIO_Port, rf_nss_Pin, GPIO_PIN_RESET);
 80001fa:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80001fe:	f042 0204 	orr.w	r2, r2, #4
 8000202:	61da      	str	r2, [r3, #28]
 8000204:	69db      	ldr	r3, [r3, #28]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(rf_nss_GPIO_Port, rf_nss_Pin, GPIO_PIN_RESET);
 8000206:	2200      	movs	r2, #0
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000208:	f003 0304 	and.w	r3, r3, #4
 800020c:	9302      	str	r3, [sp, #8]
 800020e:	9b02      	ldr	r3, [sp, #8]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(rf_nss_GPIO_Port, rf_nss_Pin, GPIO_PIN_RESET);
 8000210:	f000 fb7e 	bl	8000910 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(rf_ce_GPIO_Port, rf_ce_Pin, GPIO_PIN_RESET);
 8000214:	2200      	movs	r2, #0
 8000216:	4628      	mov	r0, r5
 8000218:	2140      	movs	r1, #64	; 0x40
 800021a:	f000 fb79 	bl	8000910 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = rf_nss_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800021e:	2400      	movs	r4, #0

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(rf_ce_GPIO_Port, rf_ce_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = rf_nss_Pin;
 8000220:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000224:	2601      	movs	r6, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(rf_nss_GPIO_Port, &GPIO_InitStruct);
 8000226:	a903      	add	r1, sp, #12
 8000228:	4638      	mov	r0, r7

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(rf_ce_GPIO_Port, rf_ce_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = rf_nss_Pin;
 800022a:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800022c:	9604      	str	r6, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800022e:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000230:	9406      	str	r4, [sp, #24]
  HAL_GPIO_Init(rf_nss_GPIO_Port, &GPIO_InitStruct);
 8000232:	f000 fa97 	bl	8000764 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = rf_ce_Pin;
 8000236:	2340      	movs	r3, #64	; 0x40
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(rf_ce_GPIO_Port, &GPIO_InitStruct);
 8000238:	a903      	add	r1, sp, #12
 800023a:	4628      	mov	r0, r5
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(rf_nss_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = rf_ce_Pin;
 800023c:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800023e:	9604      	str	r6, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000240:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000242:	9406      	str	r4, [sp, #24]
  HAL_GPIO_Init(rf_ce_GPIO_Port, &GPIO_InitStruct);
 8000244:	f000 fa8e 	bl	8000764 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = rf_irq_Pin;
 8000248:	2380      	movs	r3, #128	; 0x80
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(rf_irq_GPIO_Port, &GPIO_InitStruct);
 800024a:	a903      	add	r1, sp, #12
 800024c:	4628      	mov	r0, r5
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(rf_ce_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = rf_irq_Pin;
 800024e:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8000250:	9404      	str	r4, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000252:	9405      	str	r4, [sp, #20]
  HAL_GPIO_Init(rf_irq_GPIO_Port, &GPIO_InitStruct);
 8000254:	f000 fa86 	bl	8000764 <HAL_GPIO_Init>

}
 8000258:	b009      	add	sp, #36	; 0x24
 800025a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800025c:	40023800 	.word	0x40023800
 8000260:	40020400 	.word	0x40020400
 8000264:	40020800 	.word	0x40020800

08000268 <SystemClock_Config>:
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

    /**Configure the main internal regulator output voltage 
    */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000268:	4a1b      	ldr	r2, [pc, #108]	; (80002d8 <SystemClock_Config+0x70>)
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 800026a:	b510      	push	{r4, lr}
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

    /**Configure the main internal regulator output voltage 
    */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800026c:	6813      	ldr	r3, [r2, #0]
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 800026e:	b092      	sub	sp, #72	; 0x48
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

    /**Configure the main internal regulator output voltage 
    */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000270:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
 8000274:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000278:	6013      	str	r3, [r2, #0]

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
 800027a:	2310      	movs	r3, #16
 800027c:	9305      	str	r3, [sp, #20]
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 800027e:	2301      	movs	r3, #1
 8000280:	930b      	str	r3, [sp, #44]	; 0x2c
  RCC_OscInitStruct.MSICalibrationValue = 0;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
 8000282:	f44f 4220 	mov.w	r2, #40960	; 0xa000

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
 8000286:	2300      	movs	r3, #0
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000288:	a805      	add	r0, sp, #20

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
 800028a:	930c      	str	r3, [sp, #48]	; 0x30
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
 800028c:	920d      	str	r2, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 800028e:	930e      	str	r3, [sp, #56]	; 0x38
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000290:	f000 fb84 	bl	800099c <HAL_RCC_OscConfig>
 8000294:	4601      	mov	r1, r0
 8000296:	b100      	cbz	r0, 800029a <SystemClock_Config+0x32>
 8000298:	e7fe      	b.n	8000298 <SystemClock_Config+0x30>
    Error_Handler();
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800029a:	230f      	movs	r3, #15
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
 800029c:	9001      	str	r0, [sp, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800029e:	9002      	str	r0, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80002a0:	9003      	str	r0, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80002a2:	9004      	str	r0, [sp, #16]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 80002a4:	4668      	mov	r0, sp
    Error_Handler();
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80002a6:	9300      	str	r3, [sp, #0]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 80002a8:	f000 fefc 	bl	80010a4 <HAL_RCC_ClockConfig>
 80002ac:	4604      	mov	r4, r0
 80002ae:	b100      	cbz	r0, 80002b2 <SystemClock_Config+0x4a>
 80002b0:	e7fe      	b.n	80002b0 <SystemClock_Config+0x48>
    Error_Handler();
  }

    /**Configure the Systick interrupt time 
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 80002b2:	f000 ffbf 	bl	8001234 <HAL_RCC_GetHCLKFreq>
 80002b6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80002ba:	fbb0 f0f3 	udiv	r0, r0, r3
 80002be:	f000 fa29 	bl	8000714 <HAL_SYSTICK_Config>

    /**Configure the Systick 
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 80002c2:	2004      	movs	r0, #4
 80002c4:	f000 fa3c 	bl	8000740 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80002c8:	4622      	mov	r2, r4
 80002ca:	4621      	mov	r1, r4
 80002cc:	f04f 30ff 	mov.w	r0, #4294967295
 80002d0:	f000 f9e0 	bl	8000694 <HAL_NVIC_SetPriority>
}
 80002d4:	b012      	add	sp, #72	; 0x48
 80002d6:	bd10      	pop	{r4, pc}
 80002d8:	40007000 	.word	0x40007000

080002dc <main>:
#if defined(TEST)
	#define TEST_RECIVE
#endif

int main(void)
{
 80002dc:	b508      	push	{r3, lr}
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80002de:	f000 f99f 	bl	8000620 <HAL_Init>

  /* Configure the system clock */
  SystemClock_Config();
 80002e2:	f7ff ffc1 	bl	8000268 <SystemClock_Config>

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 80002e6:	f7ff ff6f 	bl	80001c8 <MX_GPIO_Init>
  MX_SPI2_Init();
 80002ea:	f000 f839 	bl	8000360 <MX_SPI2_Init>
  MX_USART2_UART_Init();
 80002ee:	f000 f915 	bl	800051c <MX_USART2_UART_Init>
  MX_TIM7_Init();
 80002f2:	f000 f8e3 	bl	80004bc <MX_TIM7_Init>


  /* USER CODE BEGIN 2 */

  	/* Init Radio */
	rfm7x_init(RFM73);
 80002f6:	2002      	movs	r0, #2
 80002f8:	f001 fe60 	bl	8001fbc <rfm7x_init>

	if(rfm7x_is_present())
 80002fc:	f001 fdc6 	bl	8001e8c <rfm7x_is_present>
 8000300:	b128      	cbz	r0, 800030e <main+0x32>
	{
		/* Send OK by UART */
		 HAL_UART_Transmit(&huart2,   Message_OK, Message_Length,  100);
 8000302:	2364      	movs	r3, #100	; 0x64
 8000304:	2203      	movs	r2, #3
 8000306:	4910      	ldr	r1, [pc, #64]	; (8000348 <main+0x6c>)
 8000308:	4810      	ldr	r0, [pc, #64]	; (800034c <main+0x70>)
 800030a:	f001 fbbe 	bl	8001a8a <HAL_UART_Transmit>
	}
	rfm7x_channel(45);
 800030e:	202d      	movs	r0, #45	; 0x2d
 8000310:	f001 fdf8 	bl	8001f04 <rfm7x_channel>
	rfm7x_mode_receive();
 8000314:	f001 fdd4 	bl	8001ec0 <rfm7x_mode_receive>

			   if(!rfm7x_receive_fifo_empty())//odebrano jakieœ dane
			   {//HAL_UART_Transmit(&huart2,   Message_OK, Message_Length,  100);


			        if(0 != rfm7x_receive(&rfpipe, rfmsg, &rfmsg_len) && rfmsg_len > 0) //danych jest wiêcej ni¿ 1 bajt
 8000318:	4c0d      	ldr	r4, [pc, #52]	; (8000350 <main+0x74>)
 800031a:	4d0e      	ldr	r5, [pc, #56]	; (8000354 <main+0x78>)
  for(;;)
  {

#ifdef TEST_RECIVE

			   if(!rfm7x_receive_fifo_empty())//odebrano jakieœ dane
 800031c:	f001 fdfc 	bl	8001f18 <rfm7x_receive_fifo_empty>
 8000320:	b970      	cbnz	r0, 8000340 <main+0x64>
			   {//HAL_UART_Transmit(&huart2,   Message_OK, Message_Length,  100);


			        if(0 != rfm7x_receive(&rfpipe, rfmsg, &rfmsg_len) && rfmsg_len > 0) //danych jest wiêcej ni¿ 1 bajt
 8000322:	4a0b      	ldr	r2, [pc, #44]	; (8000350 <main+0x74>)
 8000324:	490b      	ldr	r1, [pc, #44]	; (8000354 <main+0x78>)
 8000326:	480c      	ldr	r0, [pc, #48]	; (8000358 <main+0x7c>)
 8000328:	f001 fe32 	bl	8001f90 <rfm7x_receive>
 800032c:	b140      	cbz	r0, 8000340 <main+0x64>
 800032e:	7822      	ldrb	r2, [r4, #0]
 8000330:	b132      	cbz	r2, 8000340 <main+0x64>
			        {
			            rfmsg[rfmsg_len] = '\n'; //dodaj znak koñca napisu w C do bufora
 8000332:	230a      	movs	r3, #10
 8000334:	54ab      	strb	r3, [r5, r2]
			            HAL_UART_Transmit(&huart2,  rfmsg, rfmsg_len, 0xFF); //wyœwietl odebrany komunikat w terminalu
 8000336:	4907      	ldr	r1, [pc, #28]	; (8000354 <main+0x78>)
 8000338:	23ff      	movs	r3, #255	; 0xff
 800033a:	4804      	ldr	r0, [pc, #16]	; (800034c <main+0x70>)
 800033c:	f001 fba5 	bl	8001a8a <HAL_UART_Transmit>

			        }
			   }

			  HAL_Delay(100);
 8000340:	2064      	movs	r0, #100	; 0x64
 8000342:	f000 f987 	bl	8000654 <HAL_Delay>
#endif

  }
 8000346:	e7e9      	b.n	800031c <main+0x40>
 8000348:	20000000 	.word	0x20000000
 800034c:	200000d8 	.word	0x200000d8
 8000350:	20000025 	.word	0x20000025
 8000354:	20000026 	.word	0x20000026
 8000358:	20000046 	.word	0x20000046

0800035c <Error_Handler>:
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
void Error_Handler(void)
{
 800035c:	e7fe      	b.n	800035c <Error_Handler>
	...

08000360 <MX_SPI2_Init>:

SPI_HandleTypeDef hspi2;

/* SPI2 init function */
void MX_SPI2_Init(void)
{
 8000360:	b508      	push	{r3, lr}

  hspi2.Instance = SPI2;
 8000362:	480e      	ldr	r0, [pc, #56]	; (800039c <MX_SPI2_Init+0x3c>)
  hspi2.Init.Mode = SPI_MODE_MASTER;
 8000364:	4b0e      	ldr	r3, [pc, #56]	; (80003a0 <MX_SPI2_Init+0x40>)
 8000366:	f44f 7e82 	mov.w	lr, #260	; 0x104
 800036a:	e880 4008 	stmia.w	r0, {r3, lr}
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
 800036e:	2300      	movs	r3, #0
 8000370:	6083      	str	r3, [r0, #8]
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
 8000372:	60c3      	str	r3, [r0, #12]
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
 8000374:	6103      	str	r3, [r0, #16]
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
 8000376:	6143      	str	r3, [r0, #20]
  hspi2.Init.NSS = SPI_NSS_SOFT;
 8000378:	f44f 7200 	mov.w	r2, #512	; 0x200
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 800037c:	61c3      	str	r3, [r0, #28]
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 800037e:	6203      	str	r3, [r0, #32]
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
 8000380:	6243      	str	r3, [r0, #36]	; 0x24
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8000382:	6283      	str	r3, [r0, #40]	; 0x28
  hspi2.Init.CRCPolynomial = 10;
 8000384:	230a      	movs	r3, #10
  hspi2.Init.Mode = SPI_MODE_MASTER;
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi2.Init.NSS = SPI_NSS_SOFT;
 8000386:	6182      	str	r2, [r0, #24]
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi2.Init.CRCPolynomial = 10;
 8000388:	62c3      	str	r3, [r0, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
 800038a:	f001 f934 	bl	80015f6 <HAL_SPI_Init>
 800038e:	b118      	cbz	r0, 8000398 <MX_SPI2_Init+0x38>
  {
    Error_Handler();
  }

}
 8000390:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi2.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
  {
    Error_Handler();
 8000394:	f7ff bfe2 	b.w	800035c <Error_Handler>
 8000398:	bd08      	pop	{r3, pc}
 800039a:	bf00      	nop
 800039c:	20000048 	.word	0x20000048
 80003a0:	40003800 	.word	0x40003800

080003a4 <HAL_SPI_MspInit>:
  }

}

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 80003a4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(spiHandle->Instance==SPI2)
 80003a6:	6802      	ldr	r2, [r0, #0]
 80003a8:	4b0f      	ldr	r3, [pc, #60]	; (80003e8 <HAL_SPI_MspInit+0x44>)
 80003aa:	429a      	cmp	r2, r3
 80003ac:	d119      	bne.n	80003e2 <HAL_SPI_MspInit+0x3e>
  {
  /* USER CODE BEGIN SPI2_MspInit 0 */

  /* USER CODE END SPI2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI2_CLK_ENABLE();
 80003ae:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 80003b2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80003b4:	a901      	add	r1, sp, #4
  {
  /* USER CODE BEGIN SPI2_MspInit 0 */

  /* USER CODE END SPI2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI2_CLK_ENABLE();
 80003b6:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80003ba:	625a      	str	r2, [r3, #36]	; 0x24
 80003bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80003be:	480b      	ldr	r0, [pc, #44]	; (80003ec <HAL_SPI_MspInit+0x48>)
  {
  /* USER CODE BEGIN SPI2_MspInit 0 */

  /* USER CODE END SPI2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI2_CLK_ENABLE();
 80003c0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80003c4:	9300      	str	r3, [sp, #0]
 80003c6:	9b00      	ldr	r3, [sp, #0]
    /**SPI2 GPIO Configuration    
    PB13     ------> SPI2_SCK
    PB14     ------> SPI2_MISO
    PB15     ------> SPI2_MOSI 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
 80003c8:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 80003cc:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80003ce:	2302      	movs	r3, #2
 80003d0:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80003d2:	2300      	movs	r3, #0
 80003d4:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80003d6:	2303      	movs	r3, #3
 80003d8:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 80003da:	2305      	movs	r3, #5
 80003dc:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80003de:	f000 f9c1 	bl	8000764 <HAL_GPIO_Init>

  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }
}
 80003e2:	b007      	add	sp, #28
 80003e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80003e8:	40003800 	.word	0x40003800
 80003ec:	40020400 	.word	0x40020400

080003f0 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80003f0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_COMP_CLK_ENABLE();
 80003f2:	4b26      	ldr	r3, [pc, #152]	; (800048c <HAL_MspInit+0x9c>)
  __HAL_RCC_SYSCFG_CLK_ENABLE();
  __HAL_RCC_PWR_CLK_ENABLE();

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80003f4:	2003      	movs	r0, #3
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_COMP_CLK_ENABLE();
 80003f6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80003f8:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 80003fc:	625a      	str	r2, [r3, #36]	; 0x24
 80003fe:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000400:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
 8000404:	9201      	str	r2, [sp, #4]
 8000406:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000408:	6a1a      	ldr	r2, [r3, #32]
 800040a:	f042 0201 	orr.w	r2, r2, #1
 800040e:	621a      	str	r2, [r3, #32]
 8000410:	6a1a      	ldr	r2, [r3, #32]
 8000412:	f002 0201 	and.w	r2, r2, #1
 8000416:	9202      	str	r2, [sp, #8]
 8000418:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_PWR_CLK_ENABLE();
 800041a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800041c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000420:	625a      	str	r2, [r3, #36]	; 0x24
 8000422:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000424:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000428:	9303      	str	r3, [sp, #12]
 800042a:	9b03      	ldr	r3, [sp, #12]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800042c:	f000 f920 	bl	8000670 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 8000430:	2200      	movs	r2, #0
 8000432:	4611      	mov	r1, r2
 8000434:	f06f 000b 	mvn.w	r0, #11
 8000438:	f000 f92c 	bl	8000694 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 800043c:	2200      	movs	r2, #0
 800043e:	4611      	mov	r1, r2
 8000440:	f06f 000a 	mvn.w	r0, #10
 8000444:	f000 f926 	bl	8000694 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 8000448:	2200      	movs	r2, #0
 800044a:	4611      	mov	r1, r2
 800044c:	f06f 0009 	mvn.w	r0, #9
 8000450:	f000 f920 	bl	8000694 <HAL_NVIC_SetPriority>
  /* SVC_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVC_IRQn, 0, 0);
 8000454:	2200      	movs	r2, #0
 8000456:	4611      	mov	r1, r2
 8000458:	f06f 0004 	mvn.w	r0, #4
 800045c:	f000 f91a 	bl	8000694 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 8000460:	2200      	movs	r2, #0
 8000462:	4611      	mov	r1, r2
 8000464:	f06f 0003 	mvn.w	r0, #3
 8000468:	f000 f914 	bl	8000694 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 800046c:	2200      	movs	r2, #0
 800046e:	4611      	mov	r1, r2
 8000470:	f06f 0001 	mvn.w	r0, #1
 8000474:	f000 f90e 	bl	8000694 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8000478:	2200      	movs	r2, #0
 800047a:	4611      	mov	r1, r2
 800047c:	f04f 30ff 	mov.w	r0, #4294967295
 8000480:	f000 f908 	bl	8000694 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000484:	b005      	add	sp, #20
 8000486:	f85d fb04 	ldr.w	pc, [sp], #4
 800048a:	bf00      	nop
 800048c:	40023800 	.word	0x40023800

08000490 <NMI_Handler>:
 8000490:	4770      	bx	lr

08000492 <HardFault_Handler>:

/**
* @brief This function handles Hard fault interrupt.
*/
void HardFault_Handler(void)
{
 8000492:	e7fe      	b.n	8000492 <HardFault_Handler>

08000494 <MemManage_Handler>:

/**
* @brief This function handles Memory management fault.
*/
void MemManage_Handler(void)
{
 8000494:	e7fe      	b.n	8000494 <MemManage_Handler>

08000496 <BusFault_Handler>:

/**
* @brief This function handles Pre-fetch fault, memory access fault.
*/
void BusFault_Handler(void)
{
 8000496:	e7fe      	b.n	8000496 <BusFault_Handler>

08000498 <UsageFault_Handler>:

/**
* @brief This function handles Undefined instruction or illegal state.
*/
void UsageFault_Handler(void)
{
 8000498:	e7fe      	b.n	8000498 <UsageFault_Handler>

0800049a <SVC_Handler>:
 800049a:	4770      	bx	lr

0800049c <DebugMon_Handler>:
 800049c:	4770      	bx	lr

0800049e <PendSV_Handler>:

/**
* @brief This function handles Pendable request for system service.
*/
void PendSV_Handler(void)
{
 800049e:	4770      	bx	lr

080004a0 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 80004a0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80004a2:	f000 f8c9 	bl	8000638 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80004a6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 80004aa:	f000 b956 	b.w	800075a <HAL_SYSTICK_IRQHandler>
	...

080004b0 <USART2_IRQHandler>:
void USART2_IRQHandler(void)
{
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 80004b0:	4801      	ldr	r0, [pc, #4]	; (80004b8 <USART2_IRQHandler+0x8>)
 80004b2:	f001 bb49 	b.w	8001b48 <HAL_UART_IRQHandler>
 80004b6:	bf00      	nop
 80004b8:	200000d8 	.word	0x200000d8

080004bc <MX_TIM7_Init>:

TIM_HandleTypeDef htim7;

/* TIM7 init function */
void MX_TIM7_Init(void)
{
 80004bc:	b513      	push	{r0, r1, r4, lr}
  TIM_MasterConfigTypeDef sMasterConfig;

  htim7.Instance = TIM7;
  htim7.Init.Prescaler = 0;
 80004be:	4b0b      	ldr	r3, [pc, #44]	; (80004ec <MX_TIM7_Init+0x30>)
/* TIM7 init function */
void MX_TIM7_Init(void)
{
  TIM_MasterConfigTypeDef sMasterConfig;

  htim7.Instance = TIM7;
 80004c0:	480b      	ldr	r0, [pc, #44]	; (80004f0 <MX_TIM7_Init+0x34>)
  htim7.Init.Prescaler = 0;
 80004c2:	2400      	movs	r4, #0
 80004c4:	e880 0018 	stmia.w	r0, {r3, r4}
  htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
 80004c8:	6084      	str	r4, [r0, #8]
  htim7.Init.Period = 0;
 80004ca:	60c4      	str	r4, [r0, #12]
  if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
 80004cc:	f001 f912 	bl	80016f4 <HAL_TIM_Base_Init>
 80004d0:	b108      	cbz	r0, 80004d6 <MX_TIM7_Init+0x1a>
  {
    Error_Handler();
 80004d2:	f7ff ff43 	bl	800035c <Error_Handler>
  }

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
 80004d6:	4669      	mov	r1, sp
 80004d8:	4805      	ldr	r0, [pc, #20]	; (80004f0 <MX_TIM7_Init+0x34>)
  if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
  {
    Error_Handler();
  }

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80004da:	9400      	str	r4, [sp, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80004dc:	9401      	str	r4, [sp, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
 80004de:	f001 f923 	bl	8001728 <HAL_TIMEx_MasterConfigSynchronization>
 80004e2:	b108      	cbz	r0, 80004e8 <MX_TIM7_Init+0x2c>
  {
    Error_Handler();
 80004e4:	f7ff ff3a 	bl	800035c <Error_Handler>
  }

}
 80004e8:	b002      	add	sp, #8
 80004ea:	bd10      	pop	{r4, pc}
 80004ec:	40001400 	.word	0x40001400
 80004f0:	200000a0 	.word	0x200000a0

080004f4 <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{

  if(tim_baseHandle->Instance==TIM7)
 80004f4:	6802      	ldr	r2, [r0, #0]
 80004f6:	4b08      	ldr	r3, [pc, #32]	; (8000518 <HAL_TIM_Base_MspInit+0x24>)
  }

}

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{
 80004f8:	b082      	sub	sp, #8

  if(tim_baseHandle->Instance==TIM7)
 80004fa:	429a      	cmp	r2, r3
 80004fc:	d10a      	bne.n	8000514 <HAL_TIM_Base_MspInit+0x20>
  {
  /* USER CODE BEGIN TIM7_MspInit 0 */

  /* USER CODE END TIM7_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM7_CLK_ENABLE();
 80004fe:	f503 3309 	add.w	r3, r3, #140288	; 0x22400
 8000502:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000504:	f042 0220 	orr.w	r2, r2, #32
 8000508:	625a      	str	r2, [r3, #36]	; 0x24
 800050a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800050c:	f003 0320 	and.w	r3, r3, #32
 8000510:	9301      	str	r3, [sp, #4]
 8000512:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN TIM7_MspInit 1 */

  /* USER CODE END TIM7_MspInit 1 */
  }
}
 8000514:	b002      	add	sp, #8
 8000516:	4770      	bx	lr
 8000518:	40001400 	.word	0x40001400

0800051c <MX_USART2_UART_Init>:
UART_HandleTypeDef huart2;

/* USART2 init function */

void MX_USART2_UART_Init(void)
{
 800051c:	b508      	push	{r3, lr}

  huart2.Instance = USART2;
 800051e:	480b      	ldr	r0, [pc, #44]	; (800054c <MX_USART2_UART_Init+0x30>)
  huart2.Init.BaudRate = 115200;
 8000520:	4b0b      	ldr	r3, [pc, #44]	; (8000550 <MX_USART2_UART_Init+0x34>)
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8000522:	2200      	movs	r2, #0

void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
 8000524:	f44f 3ee1 	mov.w	lr, #115200	; 0x1c200
 8000528:	e880 4008 	stmia.w	r0, {r3, lr}
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_MultiProcessor_Init(&huart2, 0, UART_WAKEUPMETHOD_IDLELINE) != HAL_OK)
 800052c:	4611      	mov	r1, r2
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 800052e:	230c      	movs	r3, #12
void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8000530:	6082      	str	r2, [r0, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 8000532:	60c2      	str	r2, [r0, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 8000534:	6102      	str	r2, [r0, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8000536:	6143      	str	r3, [r0, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8000538:	6182      	str	r2, [r0, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 800053a:	61c2      	str	r2, [r0, #28]
  if (HAL_MultiProcessor_Init(&huart2, 0, UART_WAKEUPMETHOD_IDLELINE) != HAL_OK)
 800053c:	f001 fa6c 	bl	8001a18 <HAL_MultiProcessor_Init>
 8000540:	b118      	cbz	r0, 800054a <MX_USART2_UART_Init+0x2e>
  {
    Error_Handler();
  }

}
 8000542:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_MultiProcessor_Init(&huart2, 0, UART_WAKEUPMETHOD_IDLELINE) != HAL_OK)
  {
    Error_Handler();
 8000546:	f7ff bf09 	b.w	800035c <Error_Handler>
 800054a:	bd08      	pop	{r3, pc}
 800054c:	200000d8 	.word	0x200000d8
 8000550:	40004400 	.word	0x40004400

08000554 <HAL_UART_MspInit>:
  }

}

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8000554:	b510      	push	{r4, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(uartHandle->Instance==USART2)
 8000556:	6802      	ldr	r2, [r0, #0]
 8000558:	4b13      	ldr	r3, [pc, #76]	; (80005a8 <HAL_UART_MspInit+0x54>)
  }

}

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 800055a:	b086      	sub	sp, #24

  GPIO_InitTypeDef GPIO_InitStruct;
  if(uartHandle->Instance==USART2)
 800055c:	429a      	cmp	r2, r3
 800055e:	d120      	bne.n	80005a2 <HAL_UART_MspInit+0x4e>
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8000560:	f503 33fa 	add.w	r3, r3, #128000	; 0x1f400
 8000564:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000566:	2400      	movs	r4, #0
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8000568:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800056c:	625a      	str	r2, [r3, #36]	; 0x24
 800056e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000570:	a901      	add	r1, sp, #4
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8000572:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8000576:	9300      	str	r3, [sp, #0]
 8000578:	9b00      	ldr	r3, [sp, #0]
  
    /**USART2 GPIO Configuration    
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 800057a:	230c      	movs	r3, #12
 800057c:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800057e:	2302      	movs	r3, #2
 8000580:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000582:	2303      	movs	r3, #3
 8000584:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000586:	4809      	ldr	r0, [pc, #36]	; (80005ac <HAL_UART_MspInit+0x58>)
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8000588:	2307      	movs	r3, #7
 800058a:	9305      	str	r3, [sp, #20]
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800058c:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800058e:	f000 f8e9 	bl	8000764 <HAL_GPIO_Init>

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
 8000592:	2026      	movs	r0, #38	; 0x26
 8000594:	4622      	mov	r2, r4
 8000596:	4621      	mov	r1, r4
 8000598:	f000 f87c 	bl	8000694 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 800059c:	2026      	movs	r0, #38	; 0x26
 800059e:	f000 f8ad 	bl	80006fc <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
 80005a2:	b006      	add	sp, #24
 80005a4:	bd10      	pop	{r4, pc}
 80005a6:	bf00      	nop
 80005a8:	40004400 	.word	0x40004400
 80005ac:	40020000 	.word	0x40020000

080005b0 <SystemInit>:
  * @retval None
  */
void SystemInit (void)
{
  /*!< Set MSION bit */
  RCC->CR |= (uint32_t)0x00000100;
 80005b0:	4b0e      	ldr	r3, [pc, #56]	; (80005ec <SystemInit+0x3c>)
 80005b2:	681a      	ldr	r2, [r3, #0]
 80005b4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80005b8:	601a      	str	r2, [r3, #0]

  /*!< Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], MCOSEL[2:0] and MCOPRE[2:0] bits */
  RCC->CFGR &= (uint32_t)0x88FFC00C;
 80005ba:	6899      	ldr	r1, [r3, #8]
 80005bc:	4a0c      	ldr	r2, [pc, #48]	; (80005f0 <SystemInit+0x40>)
 80005be:	400a      	ands	r2, r1
 80005c0:	609a      	str	r2, [r3, #8]
  
  /*!< Reset HSION, HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xEEFEFFFE;
 80005c2:	681a      	ldr	r2, [r3, #0]
 80005c4:	f022 5288 	bic.w	r2, r2, #285212672	; 0x11000000
 80005c8:	f022 1201 	bic.w	r2, r2, #65537	; 0x10001
 80005cc:	601a      	str	r2, [r3, #0]

  /*!< Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80005ce:	681a      	ldr	r2, [r3, #0]
 80005d0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80005d4:	601a      	str	r2, [r3, #0]

  /*!< Reset PLLSRC, PLLMUL[3:0] and PLLDIV[1:0] bits */
  RCC->CFGR &= (uint32_t)0xFF02FFFF;
 80005d6:	689a      	ldr	r2, [r3, #8]
 80005d8:	f422 027d 	bic.w	r2, r2, #16580608	; 0xfd0000
 80005dc:	609a      	str	r2, [r3, #8]

  /*!< Disable all interrupts */
  RCC->CIR = 0x00000000;
 80005de:	2200      	movs	r2, #0
 80005e0:	60da      	str	r2, [r3, #12]
#endif /* DATA_IN_ExtSRAM */
    
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 80005e2:	4b04      	ldr	r3, [pc, #16]	; (80005f4 <SystemInit+0x44>)
 80005e4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80005e8:	609a      	str	r2, [r3, #8]
 80005ea:	4770      	bx	lr
 80005ec:	40023800 	.word	0x40023800
 80005f0:	88ffc00c 	.word	0x88ffc00c
 80005f4:	e000ed00 	.word	0xe000ed00

080005f8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80005f8:	b510      	push	{r4, lr}
 80005fa:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock /1000);
 80005fc:	4b07      	ldr	r3, [pc, #28]	; (800061c <HAL_InitTick+0x24>)
 80005fe:	6818      	ldr	r0, [r3, #0]
 8000600:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000604:	fbb0 f0f3 	udiv	r0, r0, r3
 8000608:	f000 f884 	bl	8000714 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 800060c:	2200      	movs	r2, #0
 800060e:	4621      	mov	r1, r4
 8000610:	f04f 30ff 	mov.w	r0, #4294967295
 8000614:	f000 f83e 	bl	8000694 <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
}
 8000618:	2000      	movs	r0, #0
 800061a:	bd10      	pop	{r4, pc}
 800061c:	20000004 	.word	0x20000004

08000620 <HAL_Init>:
  *        In the default implementation,Systick is used as source of time base.
  *        the tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000620:	b508      	push	{r3, lr}
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000622:	2003      	movs	r0, #3
 8000624:	f000 f824 	bl	8000670 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8000628:	2000      	movs	r0, #0
 800062a:	f7ff ffe5 	bl	80005f8 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 800062e:	f7ff fedf 	bl	80003f0 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8000632:	2000      	movs	r0, #0
 8000634:	bd08      	pop	{r3, pc}
	...

08000638 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000638:	4a02      	ldr	r2, [pc, #8]	; (8000644 <HAL_IncTick+0xc>)
 800063a:	6813      	ldr	r3, [r2, #0]
 800063c:	3301      	adds	r3, #1
 800063e:	6013      	str	r3, [r2, #0]
 8000640:	4770      	bx	lr
 8000642:	bf00      	nop
 8000644:	20000118 	.word	0x20000118

08000648 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000648:	4b01      	ldr	r3, [pc, #4]	; (8000650 <HAL_GetTick+0x8>)
 800064a:	6818      	ldr	r0, [r3, #0]
}
 800064c:	4770      	bx	lr
 800064e:	bf00      	nop
 8000650:	20000118 	.word	0x20000118

08000654 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 8000654:	b513      	push	{r0, r1, r4, lr}
 8000656:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
 8000658:	f7ff fff6 	bl	8000648 <HAL_GetTick>
 800065c:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 800065e:	f7ff fff3 	bl	8000648 <HAL_GetTick>
 8000662:	9b01      	ldr	r3, [sp, #4]
 8000664:	1b00      	subs	r0, r0, r4
 8000666:	4298      	cmp	r0, r3
 8000668:	d3f9      	bcc.n	800065e <HAL_Delay+0xa>
  {
  }
}
 800066a:	b002      	add	sp, #8
 800066c:	bd10      	pop	{r4, pc}
	...

08000670 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000670:	4a07      	ldr	r2, [pc, #28]	; (8000690 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000672:	0200      	lsls	r0, r0, #8
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000674:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000676:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 800067a:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 800067e:	041b      	lsls	r3, r3, #16
 8000680:	0c1b      	lsrs	r3, r3, #16
 8000682:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000686:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800068a:	4303      	orrs	r3, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800068c:	60d3      	str	r3, [r2, #12]
 800068e:	4770      	bx	lr
 8000690:	e000ed00 	.word	0xe000ed00

08000694 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000694:	4b17      	ldr	r3, [pc, #92]	; (80006f4 <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000696:	b530      	push	{r4, r5, lr}
 8000698:	68db      	ldr	r3, [r3, #12]
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800069a:	f3c3 2302 	ubfx	r3, r3, #8, #3
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800069e:	f1c3 0407 	rsb	r4, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80006a2:	1d1d      	adds	r5, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80006a4:	2c04      	cmp	r4, #4
 80006a6:	bf28      	it	cs
 80006a8:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80006aa:	2d06      	cmp	r5, #6

  return (
 80006ac:	f04f 0501 	mov.w	r5, #1
 80006b0:	fa05 f404 	lsl.w	r4, r5, r4
 80006b4:	f104 34ff 	add.w	r4, r4, #4294967295
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80006b8:	bf8c      	ite	hi
 80006ba:	3b03      	subhi	r3, #3
 80006bc:	2300      	movls	r3, #0

  return (
 80006be:	400c      	ands	r4, r1
 80006c0:	409c      	lsls	r4, r3
 80006c2:	fa05 f303 	lsl.w	r3, r5, r3
 80006c6:	3b01      	subs	r3, #1
 80006c8:	401a      	ands	r2, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 80006ca:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 80006cc:	ea42 0204 	orr.w	r2, r2, r4
 80006d0:	ea4f 1202 	mov.w	r2, r2, lsl #4
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006d4:	bfaf      	iteee	ge
 80006d6:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006da:	4b07      	ldrlt	r3, [pc, #28]	; (80006f8 <HAL_NVIC_SetPriority+0x64>)
 80006dc:	f000 000f 	andlt.w	r0, r0, #15
 80006e0:	b2d2      	uxtblt	r2, r2
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006e2:	bfa5      	ittet	ge
 80006e4:	b2d2      	uxtbge	r2, r2
 80006e6:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006ea:	541a      	strblt	r2, [r3, r0]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006ec:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 80006f0:	bd30      	pop	{r4, r5, pc}
 80006f2:	bf00      	nop
 80006f4:	e000ed00 	.word	0xe000ed00
 80006f8:	e000ed14 	.word	0xe000ed14

080006fc <HAL_NVIC_EnableIRQ>:
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80006fc:	0942      	lsrs	r2, r0, #5
 80006fe:	2301      	movs	r3, #1
 8000700:	f000 001f 	and.w	r0, r0, #31
 8000704:	fa03 f000 	lsl.w	r0, r3, r0
 8000708:	4b01      	ldr	r3, [pc, #4]	; (8000710 <HAL_NVIC_EnableIRQ+0x14>)
 800070a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 800070e:	4770      	bx	lr
 8000710:	e000e100 	.word	0xe000e100

08000714 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000714:	3801      	subs	r0, #1
 8000716:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800071a:	d20a      	bcs.n	8000732 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800071c:	4b06      	ldr	r3, [pc, #24]	; (8000738 <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800071e:	4a07      	ldr	r2, [pc, #28]	; (800073c <HAL_SYSTICK_Config+0x28>)
 8000720:	21f0      	movs	r1, #240	; 0xf0
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000722:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000724:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000728:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800072a:	2207      	movs	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800072c:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800072e:	601a      	str	r2, [r3, #0]
 8000730:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 8000732:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000734:	4770      	bx	lr
 8000736:	bf00      	nop
 8000738:	e000e010 	.word	0xe000e010
 800073c:	e000ed00 	.word	0xe000ed00

08000740 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8000740:	4b04      	ldr	r3, [pc, #16]	; (8000754 <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000742:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000744:	681a      	ldr	r2, [r3, #0]
 8000746:	bf0c      	ite	eq
 8000748:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 800074c:	f022 0204 	bicne.w	r2, r2, #4
 8000750:	601a      	str	r2, [r3, #0]
 8000752:	4770      	bx	lr
 8000754:	e000e010 	.word	0xe000e010

08000758 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8000758:	4770      	bx	lr

0800075a <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 800075a:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 800075c:	f7ff fffc 	bl	8000758 <HAL_SYSTICK_Callback>
 8000760:	bd08      	pop	{r3, pc}
	...

08000764 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
 8000764:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000768:	f8df 819c 	ldr.w	r8, [pc, #412]	; 8000908 <HAL_GPIO_Init+0x1a4>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull)); 

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 800076c:	680b      	ldr	r3, [r1, #0]
 800076e:	4644      	mov	r4, r8
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
 8000770:	b085      	sub	sp, #20
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000772:	f8df c198 	ldr.w	ip, [pc, #408]	; 800090c <HAL_GPIO_Init+0x1a8>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull)); 

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 8000776:	9301      	str	r3, [sp, #4]
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
  uint32_t position = 0x00;
 8000778:	2300      	movs	r3, #0
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull)); 

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 800077a:	9a01      	ldr	r2, [sp, #4]
 800077c:	40da      	lsrs	r2, r3
 800077e:	f000 80be 	beq.w	80008fe <HAL_GPIO_Init+0x19a>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & ((uint32_t)1 << position);
 8000782:	f04f 0e01 	mov.w	lr, #1
    
    if(iocurrent)
 8000786:	9a01      	ldr	r2, [sp, #4]

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & ((uint32_t)1 << position);
 8000788:	fa0e fe03 	lsl.w	lr, lr, r3
    
    if(iocurrent)
 800078c:	ea12 060e 	ands.w	r6, r2, lr
 8000790:	f000 80b3 	beq.w	80008fa <HAL_GPIO_Init+0x196>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 8000794:	684a      	ldr	r2, [r1, #4]
 8000796:	f022 0910 	bic.w	r9, r2, #16
 800079a:	f1b9 0f02 	cmp.w	r9, #2
 800079e:	d114      	bne.n	80007ca <HAL_GPIO_Init+0x66>
 80007a0:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 80007a4:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */ 
        /* Identify AFRL or AFRH register based on IO position*/
        temp = GPIOx->AFR[position >> 3];
        CLEAR_BIT(temp, (uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;      
 80007a8:	f003 0b07 	and.w	fp, r3, #7
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */ 
        /* Identify AFRL or AFRH register based on IO position*/
        temp = GPIOx->AFR[position >> 3];
 80007ac:	f8da 7020 	ldr.w	r7, [sl, #32]
        CLEAR_BIT(temp, (uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;      
 80007b0:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 80007b4:	250f      	movs	r5, #15
 80007b6:	fa05 f50b 	lsl.w	r5, r5, fp
 80007ba:	ea27 0505 	bic.w	r5, r7, r5
        SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));       
 80007be:	690f      	ldr	r7, [r1, #16]
 80007c0:	fa07 f70b 	lsl.w	r7, r7, fp
 80007c4:	432f      	orrs	r7, r5
        GPIOx->AFR[position >> 3] = temp;
 80007c6:	f8ca 7020 	str.w	r7, [sl, #32]
 80007ca:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
 80007ce:	2503      	movs	r5, #3
 80007d0:	fa05 f50a 	lsl.w	r5, r5, sl
 80007d4:	43ed      	mvns	r5, r5
        SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));       
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 80007d6:	6807      	ldr	r7, [r0, #0]
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80007d8:	f002 0b03 	and.w	fp, r2, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
 80007dc:	402f      	ands	r7, r5
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80007de:	fa0b fb0a 	lsl.w	fp, fp, sl
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80007e2:	f109 39ff 	add.w	r9, r9, #4294967295
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80007e6:	ea4b 0707 	orr.w	r7, fp, r7
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80007ea:	f1b9 0f01 	cmp.w	r9, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2));   
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;
 80007ee:	6007      	str	r7, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80007f0:	d811      	bhi.n	8000816 <HAL_GPIO_Init+0xb2>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 80007f2:	6887      	ldr	r7, [r0, #8]
        CLEAR_BIT(temp, GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 80007f4:	ea05 0907 	and.w	r9, r5, r7
        SET_BIT(temp, GPIO_Init->Speed << (position * 2));
 80007f8:	68cf      	ldr	r7, [r1, #12]
 80007fa:	fa07 f70a 	lsl.w	r7, r7, sl
 80007fe:	ea47 0709 	orr.w	r7, r7, r9
        GPIOx->OSPEEDR = temp;
 8000802:	6087      	str	r7, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8000804:	6847      	ldr	r7, [r0, #4]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 8000806:	ea27 0e0e 	bic.w	lr, r7, lr
        SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800080a:	f3c2 1700 	ubfx	r7, r2, #4, #1
 800080e:	409f      	lsls	r7, r3
 8000810:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8000814:	6047      	str	r7, [r0, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8000816:	68c7      	ldr	r7, [r0, #12]
      CLEAR_BIT(temp, GPIO_PUPDR_PUPDR0 << (position * 2));
 8000818:	403d      	ands	r5, r7
      SET_BIT(temp, (GPIO_Init->Pull) << (position * 2));
 800081a:	688f      	ldr	r7, [r1, #8]
 800081c:	fa07 f70a 	lsl.w	r7, r7, sl
 8000820:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 8000822:	60c5      	str	r5, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 8000824:	00d5      	lsls	r5, r2, #3
 8000826:	d568      	bpl.n	80008fa <HAL_GPIO_Init+0x196>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000828:	f8dc 5020 	ldr.w	r5, [ip, #32]
 800082c:	f023 0703 	bic.w	r7, r3, #3
 8000830:	f045 0501 	orr.w	r5, r5, #1
 8000834:	f8cc 5020 	str.w	r5, [ip, #32]
 8000838:	f8dc 5020 	ldr.w	r5, [ip, #32]
 800083c:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 8000840:	f005 0501 	and.w	r5, r5, #1
 8000844:	9503      	str	r5, [sp, #12]
 8000846:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
        
        temp = SYSCFG->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 800084a:	f003 0903 	and.w	r9, r3, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800084e:	9d03      	ldr	r5, [sp, #12]
        
        temp = SYSCFG->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000850:	f04f 0e0f 	mov.w	lr, #15
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
        
        temp = SYSCFG->EXTICR[position >> 2];
 8000854:	f8d7 a008 	ldr.w	sl, [r7, #8]
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000858:	ea4f 0989 	mov.w	r9, r9, lsl #2
 800085c:	fa0e f509 	lsl.w	r5, lr, r9
 8000860:	ea2a 0e05 	bic.w	lr, sl, r5
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000864:	4d27      	ldr	r5, [pc, #156]	; (8000904 <HAL_GPIO_Init+0x1a0>)
 8000866:	42a8      	cmp	r0, r5
 8000868:	d01a      	beq.n	80008a0 <HAL_GPIO_Init+0x13c>
 800086a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800086e:	42a8      	cmp	r0, r5
 8000870:	d018      	beq.n	80008a4 <HAL_GPIO_Init+0x140>
 8000872:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000876:	42a8      	cmp	r0, r5
 8000878:	d016      	beq.n	80008a8 <HAL_GPIO_Init+0x144>
 800087a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800087e:	42a8      	cmp	r0, r5
 8000880:	d014      	beq.n	80008ac <HAL_GPIO_Init+0x148>
 8000882:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000886:	42a8      	cmp	r0, r5
 8000888:	d012      	beq.n	80008b0 <HAL_GPIO_Init+0x14c>
 800088a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800088e:	42a8      	cmp	r0, r5
 8000890:	d010      	beq.n	80008b4 <HAL_GPIO_Init+0x150>
 8000892:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000896:	42a8      	cmp	r0, r5
 8000898:	bf14      	ite	ne
 800089a:	2507      	movne	r5, #7
 800089c:	2506      	moveq	r5, #6
 800089e:	e00a      	b.n	80008b6 <HAL_GPIO_Init+0x152>
 80008a0:	2500      	movs	r5, #0
 80008a2:	e008      	b.n	80008b6 <HAL_GPIO_Init+0x152>
 80008a4:	2501      	movs	r5, #1
 80008a6:	e006      	b.n	80008b6 <HAL_GPIO_Init+0x152>
 80008a8:	2502      	movs	r5, #2
 80008aa:	e004      	b.n	80008b6 <HAL_GPIO_Init+0x152>
 80008ac:	2503      	movs	r5, #3
 80008ae:	e002      	b.n	80008b6 <HAL_GPIO_Init+0x152>
 80008b0:	2504      	movs	r5, #4
 80008b2:	e000      	b.n	80008b6 <HAL_GPIO_Init+0x152>
 80008b4:	2505      	movs	r5, #5
 80008b6:	fa05 f509 	lsl.w	r5, r5, r9
 80008ba:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2] = temp;
 80008be:	60bd      	str	r5, [r7, #8]
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 80008c0:	43f7      	mvns	r7, r6
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80008c2:	f8d8 5000 	ldr.w	r5, [r8]
        CLEAR_BIT(temp, (uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80008c6:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 80008ca:	bf0c      	ite	eq
 80008cc:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          SET_BIT(temp, iocurrent); 
 80008ce:	4335      	orrne	r5, r6
        }
        EXTI->IMR = temp;
 80008d0:	6025      	str	r5, [r4, #0]

        temp = EXTI->EMR;
 80008d2:	6865      	ldr	r5, [r4, #4]
        CLEAR_BIT(temp, (uint32_t)iocurrent);      
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80008d4:	f412 3f00 	tst.w	r2, #131072	; 0x20000
          SET_BIT(temp, iocurrent); 
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        CLEAR_BIT(temp, (uint32_t)iocurrent);      
 80008d8:	bf0c      	ite	eq
 80008da:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          SET_BIT(temp, iocurrent); 
 80008dc:	4335      	orrne	r5, r6
        }
        EXTI->EMR = temp;
 80008de:	6065      	str	r5, [r4, #4]
  
        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 80008e0:	68a5      	ldr	r5, [r4, #8]
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80008e2:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
        }
        EXTI->EMR = temp;
  
        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 80008e6:	bf0c      	ite	eq
 80008e8:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          SET_BIT(temp, iocurrent); 
 80008ea:	4335      	orrne	r5, r6
        }
        EXTI->RTSR = temp;
 80008ec:	60a5      	str	r5, [r4, #8]

        temp = EXTI->FTSR;
 80008ee:	68e5      	ldr	r5, [r4, #12]
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80008f0:	0292      	lsls	r2, r2, #10
          SET_BIT(temp, iocurrent); 
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 80008f2:	bf54      	ite	pl
 80008f4:	403d      	andpl	r5, r7
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          SET_BIT(temp, iocurrent); 
 80008f6:	4335      	orrmi	r5, r6
        }
        EXTI->FTSR = temp;
 80008f8:	60e5      	str	r5, [r4, #12]
      }
    }
    
    position++;
 80008fa:	3301      	adds	r3, #1
 80008fc:	e73d      	b.n	800077a <HAL_GPIO_Init+0x16>
  } 
}
 80008fe:	b005      	add	sp, #20
 8000900:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000904:	40020000 	.word	0x40020000
 8000908:	40010400 	.word	0x40010400
 800090c:	40023800 	.word	0x40023800

08000910 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8000910:	b902      	cbnz	r2, 8000914 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16 ;
 8000912:	0409      	lsls	r1, r1, #16
 8000914:	6181      	str	r1, [r0, #24]
 8000916:	4770      	bx	lr

08000918 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.   
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1, PWR_REGULATOR_VOLTAGE_SCALE2 or PWR_REGULATOR_VOLTAGE_SCALE3)
  */  
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return  (PWR->CR & PWR_CR_VOS);
 8000918:	4b02      	ldr	r3, [pc, #8]	; (8000924 <HAL_PWREx_GetVoltageRange+0xc>)
 800091a:	6818      	ldr	r0, [r3, #0]
}
 800091c:	f400 50c0 	and.w	r0, r0, #6144	; 0x1800
 8000920:	4770      	bx	lr
 8000922:	bf00      	nop
 8000924:	40007000 	.word	0x40007000

08000928 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range
  * @param  MSIrange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_6
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSIrange)
{
 8000928:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  /* HCLK can reach 4 MHz only if AHB prescaler = 1 */
  if (READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 800092a:	4c1a      	ldr	r4, [pc, #104]	; (8000994 <RCC_SetFlashLatencyFromMSIRange+0x6c>)
            voltage range
  * @param  MSIrange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_6
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSIrange)
{
 800092c:	4605      	mov	r5, r0
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  /* HCLK can reach 4 MHz only if AHB prescaler = 1 */
  if (READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 800092e:	68a3      	ldr	r3, [r4, #8]
 8000930:	f013 0ff0 	tst.w	r3, #240	; 0xf0
 8000934:	d11a      	bne.n	800096c <RCC_SetFlashLatencyFromMSIRange+0x44>
  {
    if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8000936:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000938:	00db      	lsls	r3, r3, #3
 800093a:	d502      	bpl.n	8000942 <RCC_SetFlashLatencyFromMSIRange+0x1a>
    {
      vos = HAL_PWREx_GetVoltageRange();
 800093c:	f7ff ffec 	bl	8000918 <HAL_PWREx_GetVoltageRange>
 8000940:	e00e      	b.n	8000960 <RCC_SetFlashLatencyFromMSIRange+0x38>
    }
    else
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8000942:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000944:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000948:	6263      	str	r3, [r4, #36]	; 0x24
 800094a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800094c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000950:	9301      	str	r3, [sp, #4]
 8000952:	9b01      	ldr	r3, [sp, #4]
      vos = HAL_PWREx_GetVoltageRange();
 8000954:	f7ff ffe0 	bl	8000918 <HAL_PWREx_GetVoltageRange>
      __HAL_RCC_PWR_CLK_DISABLE();
 8000958:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800095a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800095e:	6263      	str	r3, [r4, #36]	; 0x24
    }
    
    /* Check if need to set latency 1 only for Range 3 & HCLK = 4MHz */
    if((vos == PWR_REGULATOR_VOLTAGE_SCALE3) && (MSIrange == RCC_MSIRANGE_6))
 8000960:	f5b0 5fc0 	cmp.w	r0, #6144	; 0x1800
 8000964:	d102      	bne.n	800096c <RCC_SetFlashLatencyFromMSIRange+0x44>
 8000966:	f5b5 4f40 	cmp.w	r5, #49152	; 0xc000
 800096a:	d001      	beq.n	8000970 <RCC_SetFlashLatencyFromMSIRange+0x48>
            voltage range
  * @param  MSIrange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_6
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSIrange)
{
 800096c:	2300      	movs	r3, #0
 800096e:	e005      	b.n	800097c <RCC_SetFlashLatencyFromMSIRange+0x54>
    {
      latency = FLASH_LATENCY_1; /* 1WS */
    }
  }
  
  __HAL_FLASH_SET_LATENCY(latency);
 8000970:	4a09      	ldr	r2, [pc, #36]	; (8000998 <RCC_SetFlashLatencyFromMSIRange+0x70>)
 8000972:	6813      	ldr	r3, [r2, #0]
 8000974:	f043 0304 	orr.w	r3, r3, #4
 8000978:	6013      	str	r3, [r2, #0]
    }
    
    /* Check if need to set latency 1 only for Range 3 & HCLK = 4MHz */
    if((vos == PWR_REGULATOR_VOLTAGE_SCALE3) && (MSIrange == RCC_MSIRANGE_6))
    {
      latency = FLASH_LATENCY_1; /* 1WS */
 800097a:	2301      	movs	r3, #1
    }
  }
  
  __HAL_FLASH_SET_LATENCY(latency);
 800097c:	4906      	ldr	r1, [pc, #24]	; (8000998 <RCC_SetFlashLatencyFromMSIRange+0x70>)
 800097e:	680a      	ldr	r2, [r1, #0]
 8000980:	f022 0201 	bic.w	r2, r2, #1
 8000984:	431a      	orrs	r2, r3
 8000986:	600a      	str	r2, [r1, #0]
  
  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 8000988:	6808      	ldr	r0, [r1, #0]
 800098a:	f000 0001 	and.w	r0, r0, #1
 800098e:	4058      	eors	r0, r3
  {
    return HAL_ERROR;
  }
  
  return HAL_OK;
}
 8000990:	b003      	add	sp, #12
 8000992:	bd30      	pop	{r4, r5, pc}
 8000994:	40023800 	.word	0x40023800
 8000998:	40023c00 	.word	0x40023c00

0800099c <HAL_RCC_OscConfig>:
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800099c:	6803      	ldr	r3, [r0, #0]
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800099e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80009a2:	07dd      	lsls	r5, r3, #31
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80009a4:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80009a6:	d403      	bmi.n	80009b0 <HAL_RCC_OscConfig+0x14>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80009a8:	6823      	ldr	r3, [r4, #0]
 80009aa:	0798      	lsls	r0, r3, #30
 80009ac:	d474      	bmi.n	8000a98 <HAL_RCC_OscConfig+0xfc>
 80009ae:	e0fb      	b.n	8000ba8 <HAL_RCC_OscConfig+0x20c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 80009b0:	4bb8      	ldr	r3, [pc, #736]	; (8000c94 <HAL_RCC_OscConfig+0x2f8>)
 80009b2:	689a      	ldr	r2, [r3, #8]
 80009b4:	f002 020c 	and.w	r2, r2, #12
 80009b8:	2a08      	cmp	r2, #8
 80009ba:	d007      	beq.n	80009cc <HAL_RCC_OscConfig+0x30>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80009bc:	689a      	ldr	r2, [r3, #8]
 80009be:	f002 020c 	and.w	r2, r2, #12
 80009c2:	2a0c      	cmp	r2, #12
 80009c4:	d117      	bne.n	80009f6 <HAL_RCC_OscConfig+0x5a>
 80009c6:	689b      	ldr	r3, [r3, #8]
 80009c8:	03d9      	lsls	r1, r3, #15
 80009ca:	d514      	bpl.n	80009f6 <HAL_RCC_OscConfig+0x5a>
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80009cc:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80009d0:	fa93 f2a3 	rbit	r2, r3
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80009d4:	4aaf      	ldr	r2, [pc, #700]	; (8000c94 <HAL_RCC_OscConfig+0x2f8>)
 80009d6:	6812      	ldr	r2, [r2, #0]
 80009d8:	fa93 f3a3 	rbit	r3, r3
 80009dc:	fab3 f383 	clz	r3, r3
 80009e0:	f003 031f 	and.w	r3, r3, #31
 80009e4:	fa22 f303 	lsr.w	r3, r2, r3
 80009e8:	07da      	lsls	r2, r3, #31
 80009ea:	d5dd      	bpl.n	80009a8 <HAL_RCC_OscConfig+0xc>
 80009ec:	6863      	ldr	r3, [r4, #4]
 80009ee:	2b00      	cmp	r3, #0
 80009f0:	d1da      	bne.n	80009a8 <HAL_RCC_OscConfig+0xc>
      {
        return HAL_ERROR;
 80009f2:	2001      	movs	r0, #1
 80009f4:	e30c      	b.n	8001010 <HAL_RCC_OscConfig+0x674>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80009f6:	6863      	ldr	r3, [r4, #4]
 80009f8:	4da6      	ldr	r5, [pc, #664]	; (8000c94 <HAL_RCC_OscConfig+0x2f8>)
 80009fa:	2b01      	cmp	r3, #1
 80009fc:	d014      	beq.n	8000a28 <HAL_RCC_OscConfig+0x8c>
 80009fe:	b96b      	cbnz	r3, 8000a1c <HAL_RCC_OscConfig+0x80>
 8000a00:	682b      	ldr	r3, [r5, #0]
 8000a02:	f44f 3600 	mov.w	r6, #131072	; 0x20000
 8000a06:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000a0a:	602b      	str	r3, [r5, #0]
 8000a0c:	682b      	ldr	r3, [r5, #0]
 8000a0e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000a12:	602b      	str	r3, [r5, #0]
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000a14:	f7ff fe18 	bl	8000648 <HAL_GetTick>
 8000a18:	4607      	mov	r7, r0
        
        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000a1a:	e02f      	b.n	8000a7c <HAL_RCC_OscConfig+0xe0>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000a1c:	2b05      	cmp	r3, #5
 8000a1e:	682b      	ldr	r3, [r5, #0]
 8000a20:	d106      	bne.n	8000a30 <HAL_RCC_OscConfig+0x94>
 8000a22:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000a26:	602b      	str	r3, [r5, #0]
 8000a28:	682b      	ldr	r3, [r5, #0]
 8000a2a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000a2e:	e005      	b.n	8000a3c <HAL_RCC_OscConfig+0xa0>
 8000a30:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000a34:	602b      	str	r3, [r5, #0]
 8000a36:	682b      	ldr	r3, [r5, #0]
 8000a38:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000a3c:	602b      	str	r3, [r5, #0]

       /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000a3e:	f7ff fe03 	bl	8000648 <HAL_GetTick>
 8000a42:	4607      	mov	r7, r0
        
        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000a44:	4e93      	ldr	r6, [pc, #588]	; (8000c94 <HAL_RCC_OscConfig+0x2f8>)
 8000a46:	f44f 3500 	mov.w	r5, #131072	; 0x20000
 8000a4a:	fa95 f3a5 	rbit	r3, r5
 8000a4e:	6832      	ldr	r2, [r6, #0]
 8000a50:	fa95 f3a5 	rbit	r3, r5
 8000a54:	fab3 f383 	clz	r3, r3
 8000a58:	f003 031f 	and.w	r3, r3, #31
 8000a5c:	fa22 f303 	lsr.w	r3, r2, r3
 8000a60:	07db      	lsls	r3, r3, #31
 8000a62:	d4a1      	bmi.n	80009a8 <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000a64:	f7ff fdf0 	bl	8000648 <HAL_GetTick>
 8000a68:	1bc0      	subs	r0, r0, r7
 8000a6a:	2864      	cmp	r0, #100	; 0x64
 8000a6c:	d9ed      	bls.n	8000a4a <HAL_RCC_OscConfig+0xae>
          {
            return HAL_TIMEOUT;
 8000a6e:	2003      	movs	r0, #3
 8000a70:	e2ce      	b.n	8001010 <HAL_RCC_OscConfig+0x674>
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000a72:	f7ff fde9 	bl	8000648 <HAL_GetTick>
 8000a76:	1bc0      	subs	r0, r0, r7
 8000a78:	2864      	cmp	r0, #100	; 0x64
 8000a7a:	d8f8      	bhi.n	8000a6e <HAL_RCC_OscConfig+0xd2>
 8000a7c:	fa96 f3a6 	rbit	r3, r6
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000a80:	682a      	ldr	r2, [r5, #0]
 8000a82:	fa96 f3a6 	rbit	r3, r6
 8000a86:	fab3 f383 	clz	r3, r3
 8000a8a:	f003 031f 	and.w	r3, r3, #31
 8000a8e:	fa22 f303 	lsr.w	r3, r2, r3
 8000a92:	07d8      	lsls	r0, r3, #31
 8000a94:	d4ed      	bmi.n	8000a72 <HAL_RCC_OscConfig+0xd6>
 8000a96:	e787      	b.n	80009a8 <HAL_RCC_OscConfig+0xc>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 8000a98:	4b7e      	ldr	r3, [pc, #504]	; (8000c94 <HAL_RCC_OscConfig+0x2f8>)
 8000a9a:	689a      	ldr	r2, [r3, #8]
 8000a9c:	f002 020c 	and.w	r2, r2, #12
 8000aa0:	2a04      	cmp	r2, #4
 8000aa2:	d007      	beq.n	8000ab4 <HAL_RCC_OscConfig+0x118>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8000aa4:	689a      	ldr	r2, [r3, #8]
 8000aa6:	f002 020c 	and.w	r2, r2, #12
 8000aaa:	2a0c      	cmp	r2, #12
 8000aac:	d125      	bne.n	8000afa <HAL_RCC_OscConfig+0x15e>
 8000aae:	689b      	ldr	r3, [r3, #8]
 8000ab0:	03d9      	lsls	r1, r3, #15
 8000ab2:	d422      	bmi.n	8000afa <HAL_RCC_OscConfig+0x15e>
 8000ab4:	2302      	movs	r3, #2
 8000ab6:	fa93 f2a3 	rbit	r2, r3
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000aba:	4a76      	ldr	r2, [pc, #472]	; (8000c94 <HAL_RCC_OscConfig+0x2f8>)
 8000abc:	6811      	ldr	r1, [r2, #0]
 8000abe:	fa93 f3a3 	rbit	r3, r3
 8000ac2:	fab3 f383 	clz	r3, r3
 8000ac6:	f003 031f 	and.w	r3, r3, #31
 8000aca:	fa21 f303 	lsr.w	r3, r1, r3
 8000ace:	f013 0f01 	tst.w	r3, #1
 8000ad2:	4613      	mov	r3, r2
 8000ad4:	d002      	beq.n	8000adc <HAL_RCC_OscConfig+0x140>
 8000ad6:	68e2      	ldr	r2, [r4, #12]
 8000ad8:	2a01      	cmp	r2, #1
 8000ada:	d18a      	bne.n	80009f2 <HAL_RCC_OscConfig+0x56>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000adc:	685a      	ldr	r2, [r3, #4]
 8000ade:	f44f 51f8 	mov.w	r1, #7936	; 0x1f00
 8000ae2:	fa91 f1a1 	rbit	r1, r1
 8000ae6:	fab1 f181 	clz	r1, r1
 8000aea:	6920      	ldr	r0, [r4, #16]
 8000aec:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 8000af0:	fa00 f101 	lsl.w	r1, r0, r1
 8000af4:	430a      	orrs	r2, r1
 8000af6:	605a      	str	r2, [r3, #4]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000af8:	e056      	b.n	8000ba8 <HAL_RCC_OscConfig+0x20c>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8000afa:	68e2      	ldr	r2, [r4, #12]
 8000afc:	2301      	movs	r3, #1
 8000afe:	b38a      	cbz	r2, 8000b64 <HAL_RCC_OscConfig+0x1c8>
 8000b00:	fa93 f2a3 	rbit	r2, r3
      {
       /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8000b04:	fab2 f282 	clz	r2, r2
 8000b08:	0092      	lsls	r2, r2, #2
 8000b0a:	f102 4284 	add.w	r2, r2, #1107296256	; 0x42000000
 8000b0e:	f502 028e 	add.w	r2, r2, #4653056	; 0x470000
 8000b12:	6013      	str	r3, [r2, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000b14:	f7ff fd98 	bl	8000648 <HAL_GetTick>
 8000b18:	4607      	mov	r7, r0
        
        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000b1a:	4e5e      	ldr	r6, [pc, #376]	; (8000c94 <HAL_RCC_OscConfig+0x2f8>)
 8000b1c:	2502      	movs	r5, #2
 8000b1e:	fa95 f3a5 	rbit	r3, r5
 8000b22:	485c      	ldr	r0, [pc, #368]	; (8000c94 <HAL_RCC_OscConfig+0x2f8>)
 8000b24:	6832      	ldr	r2, [r6, #0]
 8000b26:	fa95 f3a5 	rbit	r3, r5
 8000b2a:	fab3 f383 	clz	r3, r3
 8000b2e:	f003 031f 	and.w	r3, r3, #31
 8000b32:	fa22 f303 	lsr.w	r3, r2, r3
 8000b36:	07da      	lsls	r2, r3, #31
 8000b38:	d405      	bmi.n	8000b46 <HAL_RCC_OscConfig+0x1aa>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000b3a:	f7ff fd85 	bl	8000648 <HAL_GetTick>
 8000b3e:	1bc0      	subs	r0, r0, r7
 8000b40:	2802      	cmp	r0, #2
 8000b42:	d9ec      	bls.n	8000b1e <HAL_RCC_OscConfig+0x182>
 8000b44:	e793      	b.n	8000a6e <HAL_RCC_OscConfig+0xd2>
            return HAL_TIMEOUT;
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000b46:	6843      	ldr	r3, [r0, #4]
 8000b48:	f44f 52f8 	mov.w	r2, #7936	; 0x1f00
 8000b4c:	fa92 f2a2 	rbit	r2, r2
 8000b50:	fab2 f282 	clz	r2, r2
 8000b54:	6921      	ldr	r1, [r4, #16]
 8000b56:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 8000b5a:	fa01 f202 	lsl.w	r2, r1, r2
 8000b5e:	4313      	orrs	r3, r2
 8000b60:	6043      	str	r3, [r0, #4]
 8000b62:	e021      	b.n	8000ba8 <HAL_RCC_OscConfig+0x20c>
 8000b64:	fa93 f3a3 	rbit	r3, r3
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8000b68:	fab3 f383 	clz	r3, r3
 8000b6c:	009b      	lsls	r3, r3, #2
 8000b6e:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000b72:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8000b76:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000b78:	f7ff fd66 	bl	8000648 <HAL_GetTick>
 8000b7c:	4607      	mov	r7, r0
        
        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000b7e:	4e45      	ldr	r6, [pc, #276]	; (8000c94 <HAL_RCC_OscConfig+0x2f8>)
 8000b80:	2502      	movs	r5, #2
 8000b82:	fa95 f3a5 	rbit	r3, r5
 8000b86:	6832      	ldr	r2, [r6, #0]
 8000b88:	fa95 f3a5 	rbit	r3, r5
 8000b8c:	fab3 f383 	clz	r3, r3
 8000b90:	f003 031f 	and.w	r3, r3, #31
 8000b94:	fa22 f303 	lsr.w	r3, r2, r3
 8000b98:	07db      	lsls	r3, r3, #31
 8000b9a:	d505      	bpl.n	8000ba8 <HAL_RCC_OscConfig+0x20c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000b9c:	f7ff fd54 	bl	8000648 <HAL_GetTick>
 8000ba0:	1bc0      	subs	r0, r0, r7
 8000ba2:	2802      	cmp	r0, #2
 8000ba4:	d9ed      	bls.n	8000b82 <HAL_RCC_OscConfig+0x1e6>
 8000ba6:	e762      	b.n	8000a6e <HAL_RCC_OscConfig+0xd2>
        }
      }
    }
  }
  /*----------------------------- MSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8000ba8:	6823      	ldr	r3, [r4, #0]
 8000baa:	06d8      	lsls	r0, r3, #27
 8000bac:	f140 80d8 	bpl.w	8000d60 <HAL_RCC_OscConfig+0x3c4>
  {
    /* When the MSI is used as system clock it will not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
 8000bb0:	4d38      	ldr	r5, [pc, #224]	; (8000c94 <HAL_RCC_OscConfig+0x2f8>)
 8000bb2:	68ab      	ldr	r3, [r5, #8]
 8000bb4:	f013 0f0c 	tst.w	r3, #12
 8000bb8:	d172      	bne.n	8000ca0 <HAL_RCC_OscConfig+0x304>
 8000bba:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000bbe:	fa93 f2a3 	rbit	r2, r3
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8000bc2:	682a      	ldr	r2, [r5, #0]
 8000bc4:	fa93 f3a3 	rbit	r3, r3
 8000bc8:	fab3 f383 	clz	r3, r3
 8000bcc:	f003 031f 	and.w	r3, r3, #31
 8000bd0:	fa22 f303 	lsr.w	r3, r2, r3
 8000bd4:	07d9      	lsls	r1, r3, #31
 8000bd6:	d503      	bpl.n	8000be0 <HAL_RCC_OscConfig+0x244>
 8000bd8:	69a3      	ldr	r3, [r4, #24]
 8000bda:	2b00      	cmp	r3, #0
 8000bdc:	f43f af09 	beq.w	80009f2 <HAL_RCC_OscConfig+0x56>
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8000be0:	4d2c      	ldr	r5, [pc, #176]	; (8000c94 <HAL_RCC_OscConfig+0x2f8>)
 8000be2:	6a20      	ldr	r0, [r4, #32]
 8000be4:	686b      	ldr	r3, [r5, #4]
 8000be6:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8000bea:	4298      	cmp	r0, r3
 8000bec:	d919      	bls.n	8000c22 <HAL_RCC_OscConfig+0x286>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8000bee:	f7ff fe9b 	bl	8000928 <RCC_SetFlashLatencyFromMSIRange>
 8000bf2:	2800      	cmp	r0, #0
 8000bf4:	f47f aefd 	bne.w	80009f2 <HAL_RCC_OscConfig+0x56>
          {
            return HAL_ERROR;
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8000bf8:	686b      	ldr	r3, [r5, #4]
 8000bfa:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 8000bfe:	6a23      	ldr	r3, [r4, #32]
 8000c00:	4313      	orrs	r3, r2
 8000c02:	606b      	str	r3, [r5, #4]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8000c04:	686b      	ldr	r3, [r5, #4]
 8000c06:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
 8000c0a:	fa92 f2a2 	rbit	r2, r2
 8000c0e:	fab2 f282 	clz	r2, r2
 8000c12:	69e1      	ldr	r1, [r4, #28]
 8000c14:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000c18:	fa01 f202 	lsl.w	r2, r1, r2
 8000c1c:	4313      	orrs	r3, r2
 8000c1e:	606b      	str	r3, [r5, #4]
 8000c20:	e017      	b.n	8000c52 <HAL_RCC_OscConfig+0x2b6>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8000c22:	686b      	ldr	r3, [r5, #4]
 8000c24:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
 8000c28:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8000c2c:	4303      	orrs	r3, r0
 8000c2e:	606b      	str	r3, [r5, #4]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8000c30:	686b      	ldr	r3, [r5, #4]
 8000c32:	fa92 f2a2 	rbit	r2, r2
 8000c36:	fab2 f282 	clz	r2, r2
 8000c3a:	69e1      	ldr	r1, [r4, #28]
 8000c3c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000c40:	fa01 f202 	lsl.w	r2, r1, r2
 8000c44:	4313      	orrs	r3, r2
 8000c46:	606b      	str	r3, [r5, #4]

          /* Decrease number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8000c48:	f7ff fe6e 	bl	8000928 <RCC_SetFlashLatencyFromMSIRange>
 8000c4c:	2800      	cmp	r0, #0
 8000c4e:	f47f aed0 	bne.w	80009f2 <HAL_RCC_OscConfig+0x56>
 8000c52:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 8000c56:	fa93 f3a3 	rbit	r3, r3
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000c5a:	fab3 f583 	clz	r5, r3
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];
 8000c5e:	4b0d      	ldr	r3, [pc, #52]	; (8000c94 <HAL_RCC_OscConfig+0x2f8>)
 8000c60:	22f0      	movs	r2, #240	; 0xf0
 8000c62:	6899      	ldr	r1, [r3, #8]
 8000c64:	fa92 f2a2 	rbit	r2, r2
 8000c68:	fab2 f082 	clz	r0, r2
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000c6c:	6a23      	ldr	r3, [r4, #32]
 8000c6e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8000c72:	40eb      	lsrs	r3, r5
 8000c74:	3301      	adds	r3, #1
 8000c76:	fa02 f303 	lsl.w	r3, r2, r3
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];
 8000c7a:	f001 02f0 	and.w	r2, r1, #240	; 0xf0
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000c7e:	4906      	ldr	r1, [pc, #24]	; (8000c98 <HAL_RCC_OscConfig+0x2fc>)
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];
 8000c80:	40c2      	lsrs	r2, r0
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000c82:	5c8a      	ldrb	r2, [r1, r2]
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];

        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
 8000c84:	2000      	movs	r0, #0
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
 8000c86:	40d3      	lsrs	r3, r2
 8000c88:	4a04      	ldr	r2, [pc, #16]	; (8000c9c <HAL_RCC_OscConfig+0x300>)
 8000c8a:	6013      	str	r3, [r2, #0]
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];

        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
 8000c8c:	f7ff fcb4 	bl	80005f8 <HAL_InitTick>
 8000c90:	e066      	b.n	8000d60 <HAL_RCC_OscConfig+0x3c4>
 8000c92:	bf00      	nop
 8000c94:	40023800 	.word	0x40023800
 8000c98:	080020fc 	.word	0x080020fc
 8000c9c:	20000004 	.word	0x20000004
    {
      /* Check MSI State */
      assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));

      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8000ca0:	69a2      	ldr	r2, [r4, #24]
 8000ca2:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000ca6:	2a00      	cmp	r2, #0
 8000ca8:	d038      	beq.n	8000d1c <HAL_RCC_OscConfig+0x380>
 8000caa:	fa93 f3a3 	rbit	r3, r3
      {
        /* Enable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8000cae:	fab3 f383 	clz	r3, r3
 8000cb2:	009b      	lsls	r3, r3, #2
 8000cb4:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000cb8:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8000cbc:	2201      	movs	r2, #1
 8000cbe:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000cc0:	f7ff fcc2 	bl	8000648 <HAL_GetTick>
 8000cc4:	4607      	mov	r7, r0
 8000cc6:	f44f 7600 	mov.w	r6, #512	; 0x200
 8000cca:	fa96 f3a6 	rbit	r3, r6

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 8000cce:	49bb      	ldr	r1, [pc, #748]	; (8000fbc <HAL_RCC_OscConfig+0x620>)
 8000cd0:	682a      	ldr	r2, [r5, #0]
 8000cd2:	fa96 f3a6 	rbit	r3, r6
 8000cd6:	fab3 f383 	clz	r3, r3
 8000cda:	f003 031f 	and.w	r3, r3, #31
 8000cde:	fa22 f303 	lsr.w	r3, r2, r3
 8000ce2:	07da      	lsls	r2, r3, #31
 8000ce4:	d405      	bmi.n	8000cf2 <HAL_RCC_OscConfig+0x356>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8000ce6:	f7ff fcaf 	bl	8000648 <HAL_GetTick>
 8000cea:	1bc0      	subs	r0, r0, r7
 8000cec:	2802      	cmp	r0, #2
 8000cee:	d9ec      	bls.n	8000cca <HAL_RCC_OscConfig+0x32e>
 8000cf0:	e6bd      	b.n	8000a6e <HAL_RCC_OscConfig+0xd2>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8000cf2:	684b      	ldr	r3, [r1, #4]
 8000cf4:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 8000cf8:	6a23      	ldr	r3, [r4, #32]
 8000cfa:	4313      	orrs	r3, r2
 8000cfc:	604b      	str	r3, [r1, #4]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8000cfe:	684b      	ldr	r3, [r1, #4]
 8000d00:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
 8000d04:	fa92 f2a2 	rbit	r2, r2
 8000d08:	fab2 f282 	clz	r2, r2
 8000d0c:	69e0      	ldr	r0, [r4, #28]
 8000d0e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000d12:	fa00 f202 	lsl.w	r2, r0, r2
 8000d16:	4313      	orrs	r3, r2
 8000d18:	604b      	str	r3, [r1, #4]
 8000d1a:	e021      	b.n	8000d60 <HAL_RCC_OscConfig+0x3c4>
 8000d1c:	fa93 f3a3 	rbit	r3, r3

      }
      else
      {
        /* Disable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8000d20:	fab3 f383 	clz	r3, r3
 8000d24:	009b      	lsls	r3, r3, #2
 8000d26:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000d2a:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8000d2e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000d30:	f7ff fc8a 	bl	8000648 <HAL_GetTick>
 8000d34:	4607      	mov	r7, r0
 8000d36:	f44f 7600 	mov.w	r6, #512	; 0x200
 8000d3a:	fa96 f3a6 	rbit	r3, r6

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
 8000d3e:	682a      	ldr	r2, [r5, #0]
 8000d40:	fa96 f3a6 	rbit	r3, r6
 8000d44:	fab3 f383 	clz	r3, r3
 8000d48:	f003 031f 	and.w	r3, r3, #31
 8000d4c:	fa22 f303 	lsr.w	r3, r2, r3
 8000d50:	07db      	lsls	r3, r3, #31
 8000d52:	d505      	bpl.n	8000d60 <HAL_RCC_OscConfig+0x3c4>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8000d54:	f7ff fc78 	bl	8000648 <HAL_GetTick>
 8000d58:	1bc0      	subs	r0, r0, r7
 8000d5a:	2802      	cmp	r0, #2
 8000d5c:	d9ed      	bls.n	8000d3a <HAL_RCC_OscConfig+0x39e>
 8000d5e:	e686      	b.n	8000a6e <HAL_RCC_OscConfig+0xd2>
        }
      }
    }
  }  
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8000d60:	6823      	ldr	r3, [r4, #0]
 8000d62:	0718      	lsls	r0, r3, #28
 8000d64:	d403      	bmi.n	8000d6e <HAL_RCC_OscConfig+0x3d2>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000d66:	6823      	ldr	r3, [r4, #0]
 8000d68:	0759      	lsls	r1, r3, #29
 8000d6a:	d440      	bmi.n	8000dee <HAL_RCC_OscConfig+0x452>
 8000d6c:	e0c2      	b.n	8000ef4 <HAL_RCC_OscConfig+0x558>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    
    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8000d6e:	6962      	ldr	r2, [r4, #20]
 8000d70:	2301      	movs	r3, #1
 8000d72:	4993      	ldr	r1, [pc, #588]	; (8000fc0 <HAL_RCC_OscConfig+0x624>)
 8000d74:	b1ea      	cbz	r2, 8000db2 <HAL_RCC_OscConfig+0x416>
 8000d76:	fa93 f2a3 	rbit	r2, r3
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8000d7a:	fab2 f282 	clz	r2, r2
 8000d7e:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000d82:	f7ff fc61 	bl	8000648 <HAL_GetTick>
 8000d86:	4607      	mov	r7, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000d88:	4e8c      	ldr	r6, [pc, #560]	; (8000fbc <HAL_RCC_OscConfig+0x620>)
 8000d8a:	2502      	movs	r5, #2
 8000d8c:	fa95 f3a5 	rbit	r3, r5
 8000d90:	6b72      	ldr	r2, [r6, #52]	; 0x34
 8000d92:	fa95 f3a5 	rbit	r3, r5
 8000d96:	fab3 f383 	clz	r3, r3
 8000d9a:	f003 031f 	and.w	r3, r3, #31
 8000d9e:	fa22 f303 	lsr.w	r3, r2, r3
 8000da2:	07da      	lsls	r2, r3, #31
 8000da4:	d4df      	bmi.n	8000d66 <HAL_RCC_OscConfig+0x3ca>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000da6:	f7ff fc4f 	bl	8000648 <HAL_GetTick>
 8000daa:	1bc0      	subs	r0, r0, r7
 8000dac:	2802      	cmp	r0, #2
 8000dae:	d9ed      	bls.n	8000d8c <HAL_RCC_OscConfig+0x3f0>
 8000db0:	e65d      	b.n	8000a6e <HAL_RCC_OscConfig+0xd2>
 8000db2:	fa93 f3a3 	rbit	r3, r3
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8000db6:	fab3 f383 	clz	r3, r3
 8000dba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000dbe:	f7ff fc43 	bl	8000648 <HAL_GetTick>
 8000dc2:	4607      	mov	r7, r0
      
      /* Wait till LSI is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000dc4:	4e7d      	ldr	r6, [pc, #500]	; (8000fbc <HAL_RCC_OscConfig+0x620>)
 8000dc6:	2502      	movs	r5, #2
 8000dc8:	fa95 f3a5 	rbit	r3, r5
 8000dcc:	6b72      	ldr	r2, [r6, #52]	; 0x34
 8000dce:	fa95 f3a5 	rbit	r3, r5
 8000dd2:	fab3 f383 	clz	r3, r3
 8000dd6:	f003 031f 	and.w	r3, r3, #31
 8000dda:	fa22 f303 	lsr.w	r3, r2, r3
 8000dde:	07db      	lsls	r3, r3, #31
 8000de0:	d5c1      	bpl.n	8000d66 <HAL_RCC_OscConfig+0x3ca>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000de2:	f7ff fc31 	bl	8000648 <HAL_GetTick>
 8000de6:	1bc0      	subs	r0, r0, r7
 8000de8:	2802      	cmp	r0, #2
 8000dea:	d9ed      	bls.n	8000dc8 <HAL_RCC_OscConfig+0x42c>
 8000dec:	e63f      	b.n	8000a6e <HAL_RCC_OscConfig+0xd2>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000dee:	4b73      	ldr	r3, [pc, #460]	; (8000fbc <HAL_RCC_OscConfig+0x620>)
 8000df0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000df2:	00d0      	lsls	r0, r2, #3
 8000df4:	d40a      	bmi.n	8000e0c <HAL_RCC_OscConfig+0x470>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8000df6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
      pwrclkchanged = SET;
 8000df8:	2601      	movs	r6, #1

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8000dfa:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000dfe:	625a      	str	r2, [r3, #36]	; 0x24
 8000e00:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000e02:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000e06:	9301      	str	r3, [sp, #4]
 8000e08:	9b01      	ldr	r3, [sp, #4]
 8000e0a:	e000      	b.n	8000e0e <HAL_RCC_OscConfig+0x472>
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    FlagStatus       pwrclkchanged = RESET;
 8000e0c:	2600      	movs	r6, #0
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000e0e:	4d6d      	ldr	r5, [pc, #436]	; (8000fc4 <HAL_RCC_OscConfig+0x628>)
 8000e10:	682b      	ldr	r3, [r5, #0]
 8000e12:	05d9      	lsls	r1, r3, #23
 8000e14:	d504      	bpl.n	8000e20 <HAL_RCC_OscConfig+0x484>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000e16:	68a3      	ldr	r3, [r4, #8]
 8000e18:	4d68      	ldr	r5, [pc, #416]	; (8000fbc <HAL_RCC_OscConfig+0x620>)
 8000e1a:	2b01      	cmp	r3, #1
 8000e1c:	d110      	bne.n	8000e40 <HAL_RCC_OscConfig+0x4a4>
 8000e1e:	e026      	b.n	8000e6e <HAL_RCC_OscConfig+0x4d2>
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8000e20:	682b      	ldr	r3, [r5, #0]
 8000e22:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000e26:	602b      	str	r3, [r5, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8000e28:	f7ff fc0e 	bl	8000648 <HAL_GetTick>
 8000e2c:	4607      	mov	r7, r0

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000e2e:	682b      	ldr	r3, [r5, #0]
 8000e30:	05da      	lsls	r2, r3, #23
 8000e32:	d4f0      	bmi.n	8000e16 <HAL_RCC_OscConfig+0x47a>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8000e34:	f7ff fc08 	bl	8000648 <HAL_GetTick>
 8000e38:	1bc0      	subs	r0, r0, r7
 8000e3a:	2864      	cmp	r0, #100	; 0x64
 8000e3c:	d9f7      	bls.n	8000e2e <HAL_RCC_OscConfig+0x492>
 8000e3e:	e616      	b.n	8000a6e <HAL_RCC_OscConfig+0xd2>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000e40:	b97b      	cbnz	r3, 8000e62 <HAL_RCC_OscConfig+0x4c6>
 8000e42:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000e44:	f44f 7700 	mov.w	r7, #512	; 0x200
 8000e48:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000e4c:	636b      	str	r3, [r5, #52]	; 0x34
 8000e4e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000e50:	f241 3988 	movw	r9, #5000	; 0x1388
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000e54:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000e58:	636b      	str	r3, [r5, #52]	; 0x34
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000e5a:	f7ff fbf5 	bl	8000648 <HAL_GetTick>
 8000e5e:	4680      	mov	r8, r0
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000e60:	e035      	b.n	8000ece <HAL_RCC_OscConfig+0x532>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000e62:	2b05      	cmp	r3, #5
 8000e64:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000e66:	d106      	bne.n	8000e76 <HAL_RCC_OscConfig+0x4da>
 8000e68:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000e6c:	636b      	str	r3, [r5, #52]	; 0x34
 8000e6e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000e70:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000e74:	e005      	b.n	8000e82 <HAL_RCC_OscConfig+0x4e6>
 8000e76:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000e7a:	636b      	str	r3, [r5, #52]	; 0x34
 8000e7c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000e7e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000e82:	636b      	str	r3, [r5, #52]	; 0x34
    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000e84:	f7ff fbe0 	bl	8000648 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000e88:	f241 3788 	movw	r7, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000e8c:	4681      	mov	r9, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000e8e:	f8df 812c 	ldr.w	r8, [pc, #300]	; 8000fbc <HAL_RCC_OscConfig+0x620>
 8000e92:	f44f 7500 	mov.w	r5, #512	; 0x200
 8000e96:	fa95 f3a5 	rbit	r3, r5
 8000e9a:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
 8000e9e:	fa95 f3a5 	rbit	r3, r5
 8000ea2:	fab3 f383 	clz	r3, r3
 8000ea6:	f003 031f 	and.w	r3, r3, #31
 8000eaa:	fa22 f303 	lsr.w	r3, r2, r3
 8000eae:	07db      	lsls	r3, r3, #31
 8000eb0:	d41a      	bmi.n	8000ee8 <HAL_RCC_OscConfig+0x54c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000eb2:	f7ff fbc9 	bl	8000648 <HAL_GetTick>
 8000eb6:	ebc9 0000 	rsb	r0, r9, r0
 8000eba:	42b8      	cmp	r0, r7
 8000ebc:	d9eb      	bls.n	8000e96 <HAL_RCC_OscConfig+0x4fa>
 8000ebe:	e5d6      	b.n	8000a6e <HAL_RCC_OscConfig+0xd2>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000ec0:	f7ff fbc2 	bl	8000648 <HAL_GetTick>
 8000ec4:	ebc8 0000 	rsb	r0, r8, r0
 8000ec8:	4548      	cmp	r0, r9
 8000eca:	f63f add0 	bhi.w	8000a6e <HAL_RCC_OscConfig+0xd2>
 8000ece:	fa97 f3a7 	rbit	r3, r7
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000ed2:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8000ed4:	fa97 f3a7 	rbit	r3, r7
 8000ed8:	fab3 f383 	clz	r3, r3
 8000edc:	f003 031f 	and.w	r3, r3, #31
 8000ee0:	fa22 f303 	lsr.w	r3, r2, r3
 8000ee4:	07d8      	lsls	r0, r3, #31
 8000ee6:	d4eb      	bmi.n	8000ec0 <HAL_RCC_OscConfig+0x524>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 8000ee8:	b126      	cbz	r6, 8000ef4 <HAL_RCC_OscConfig+0x558>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8000eea:	4a34      	ldr	r2, [pc, #208]	; (8000fbc <HAL_RCC_OscConfig+0x620>)
 8000eec:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8000eee:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8000ef2:	6253      	str	r3, [r2, #36]	; 0x24
  }

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000ef4:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000ef6:	b90a      	cbnz	r2, 8000efc <HAL_RCC_OscConfig+0x560>
    {
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
 8000ef8:	2000      	movs	r0, #0
 8000efa:	e089      	b.n	8001010 <HAL_RCC_OscConfig+0x674>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000efc:	4d2f      	ldr	r5, [pc, #188]	; (8000fbc <HAL_RCC_OscConfig+0x620>)
 8000efe:	68ab      	ldr	r3, [r5, #8]
 8000f00:	f003 030c 	and.w	r3, r3, #12
 8000f04:	2b0c      	cmp	r3, #12
 8000f06:	f43f ad74 	beq.w	80009f2 <HAL_RCC_OscConfig+0x56>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8000f0a:	2a02      	cmp	r2, #2
 8000f0c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8000f10:	d15a      	bne.n	8000fc8 <HAL_RCC_OscConfig+0x62c>
 8000f12:	fa93 f3a3 	rbit	r3, r3
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));
  
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8000f16:	fab3 f383 	clz	r3, r3
 8000f1a:	009b      	lsls	r3, r3, #2
 8000f1c:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000f20:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8000f24:	2200      	movs	r2, #0
 8000f26:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000f28:	f7ff fb8e 	bl	8000648 <HAL_GetTick>
 8000f2c:	4680      	mov	r8, r0
 8000f2e:	f04f 7700 	mov.w	r7, #33554432	; 0x2000000
 8000f32:	fa97 f3a7 	rbit	r3, r7
        
        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000f36:	4e21      	ldr	r6, [pc, #132]	; (8000fbc <HAL_RCC_OscConfig+0x620>)
 8000f38:	682a      	ldr	r2, [r5, #0]
 8000f3a:	fa97 f3a7 	rbit	r3, r7
 8000f3e:	fab3 f383 	clz	r3, r3
 8000f42:	f003 031f 	and.w	r3, r3, #31
 8000f46:	fa22 f303 	lsr.w	r3, r2, r3
 8000f4a:	07d9      	lsls	r1, r3, #31
 8000f4c:	d506      	bpl.n	8000f5c <HAL_RCC_OscConfig+0x5c0>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000f4e:	f7ff fb7b 	bl	8000648 <HAL_GetTick>
 8000f52:	ebc8 0000 	rsb	r0, r8, r0
 8000f56:	2802      	cmp	r0, #2
 8000f58:	d9eb      	bls.n	8000f32 <HAL_RCC_OscConfig+0x596>
 8000f5a:	e588      	b.n	8000a6e <HAL_RCC_OscConfig+0xd2>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000f5c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000f5e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000f60:	68b3      	ldr	r3, [r6, #8]
 8000f62:	4311      	orrs	r1, r2
 8000f64:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8000f66:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 8000f6a:	430a      	orrs	r2, r1
 8000f6c:	4313      	orrs	r3, r2
 8000f6e:	60b3      	str	r3, [r6, #8]
 8000f70:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8000f74:	fa93 f3a3 	rbit	r3, r3
                             RCC_OscInitStruct->PLL.PLLMUL,
                             RCC_OscInitStruct->PLL.PLLDIV);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8000f78:	fab3 f383 	clz	r3, r3
 8000f7c:	009b      	lsls	r3, r3, #2
 8000f7e:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000f82:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8000f86:	2201      	movs	r2, #1
 8000f88:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000f8a:	f7ff fb5d 	bl	8000648 <HAL_GetTick>
 8000f8e:	4605      	mov	r5, r0
 8000f90:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
 8000f94:	fa94 f3a4 	rbit	r3, r4
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000f98:	6832      	ldr	r2, [r6, #0]
 8000f9a:	fa94 f3a4 	rbit	r3, r4
 8000f9e:	fab3 f383 	clz	r3, r3
 8000fa2:	f003 031f 	and.w	r3, r3, #31
 8000fa6:	fa22 f303 	lsr.w	r3, r2, r3
 8000faa:	07da      	lsls	r2, r3, #31
 8000fac:	d4a4      	bmi.n	8000ef8 <HAL_RCC_OscConfig+0x55c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000fae:	f7ff fb4b 	bl	8000648 <HAL_GetTick>
 8000fb2:	1b40      	subs	r0, r0, r5
 8000fb4:	2802      	cmp	r0, #2
 8000fb6:	d9ed      	bls.n	8000f94 <HAL_RCC_OscConfig+0x5f8>
 8000fb8:	e559      	b.n	8000a6e <HAL_RCC_OscConfig+0xd2>
 8000fba:	bf00      	nop
 8000fbc:	40023800 	.word	0x40023800
 8000fc0:	42470680 	.word	0x42470680
 8000fc4:	40007000 	.word	0x40007000
 8000fc8:	fa93 f3a3 	rbit	r3, r3
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8000fcc:	fab3 f383 	clz	r3, r3
 8000fd0:	009b      	lsls	r3, r3, #2
 8000fd2:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000fd6:	f503 038e 	add.w	r3, r3, #4653056	; 0x470000
 8000fda:	2200      	movs	r2, #0
 8000fdc:	601a      	str	r2, [r3, #0]
 
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000fde:	f7ff fb33 	bl	8000648 <HAL_GetTick>
 8000fe2:	4606      	mov	r6, r0
 8000fe4:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
 8000fe8:	fa94 f3a4 	rbit	r3, r4
        
        /* Wait till PLL is disabled */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000fec:	682a      	ldr	r2, [r5, #0]
 8000fee:	fa94 f3a4 	rbit	r3, r4
 8000ff2:	fab3 f383 	clz	r3, r3
 8000ff6:	f003 031f 	and.w	r3, r3, #31
 8000ffa:	fa22 f303 	lsr.w	r3, r2, r3
 8000ffe:	07db      	lsls	r3, r3, #31
 8001000:	f57f af7a 	bpl.w	8000ef8 <HAL_RCC_OscConfig+0x55c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001004:	f7ff fb20 	bl	8000648 <HAL_GetTick>
 8001008:	1b80      	subs	r0, r0, r6
 800100a:	2802      	cmp	r0, #2
 800100c:	d9ec      	bls.n	8000fe8 <HAL_RCC_OscConfig+0x64c>
 800100e:	e52e      	b.n	8000a6e <HAL_RCC_OscConfig+0xd2>
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
}
 8001010:	b003      	add	sp, #12
 8001012:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001016:	bf00      	nop

08001018 <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t tmpreg = 0, pllm = 0, plld = 0, pllvco = 0, msiclkrange = 0;
  uint32_t sysclockfreq = 0;
  
  tmpreg = RCC->CFGR;
 8001018:	491e      	ldr	r1, [pc, #120]	; (8001094 <HAL_RCC_GetSysClockFreq+0x7c>)
 800101a:	688b      	ldr	r3, [r1, #8]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 800101c:	f003 020c 	and.w	r2, r3, #12
 8001020:	2a08      	cmp	r2, #8
 8001022:	d014      	beq.n	800104e <HAL_RCC_GetSysClockFreq+0x36>
 8001024:	2a0c      	cmp	r2, #12
 8001026:	d014      	beq.n	8001052 <HAL_RCC_GetSysClockFreq+0x3a>
 8001028:	2a04      	cmp	r2, #4
 800102a:	d031      	beq.n	8001090 <HAL_RCC_GetSysClockFreq+0x78>
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
    default: /* MSI used as system clock */
    {
      msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_BITNUMBER;
 800102c:	684b      	ldr	r3, [r1, #4]
 800102e:	f44f 4060 	mov.w	r0, #57344	; 0xe000
 8001032:	fa90 f0a0 	rbit	r0, r0
 8001036:	fab0 f080 	clz	r0, r0
      sysclockfreq = (32768 * (1 << (msiclkrange + 1)));
 800103a:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 800103e:	fa23 f000 	lsr.w	r0, r3, r0
 8001042:	3001      	adds	r0, #1
 8001044:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8001048:	fa03 f000 	lsl.w	r0, r3, r0
 800104c:	4770      	bx	lr
      sysclockfreq = HSI_VALUE;
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 800104e:	4812      	ldr	r0, [pc, #72]	; (8001098 <HAL_RCC_GetSysClockFreq+0x80>)
 8001050:	4770      	bx	lr
 8001052:	f44f 1270 	mov.w	r2, #3932160	; 0x3c0000
 8001056:	fa92 f2a2 	rbit	r2, r2
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 800105a:	fab2 f282 	clz	r2, r2
 800105e:	f403 1070 	and.w	r0, r3, #3932160	; 0x3c0000
 8001062:	fa20 f202 	lsr.w	r2, r0, r2
 8001066:	480d      	ldr	r0, [pc, #52]	; (800109c <HAL_RCC_GetSysClockFreq+0x84>)
 8001068:	5c80      	ldrb	r0, [r0, r2]
 800106a:	f44f 0240 	mov.w	r2, #12582912	; 0xc00000
 800106e:	fa92 f2a2 	rbit	r2, r2
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_BITNUMBER) + 1;
 8001072:	fab2 f282 	clz	r2, r2
 8001076:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 800107a:	40d3      	lsrs	r3, r2
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800107c:	688a      	ldr	r2, [r1, #8]
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_BITNUMBER) + 1;
 800107e:	3301      	adds	r3, #1
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001080:	03d2      	lsls	r2, r2, #15
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE * pllm) / plld;
 8001082:	bf4c      	ite	mi
 8001084:	4a04      	ldrmi	r2, [pc, #16]	; (8001098 <HAL_RCC_GetSysClockFreq+0x80>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE * pllm) / plld;
 8001086:	4a06      	ldrpl	r2, [pc, #24]	; (80010a0 <HAL_RCC_GetSysClockFreq+0x88>)
 8001088:	4350      	muls	r0, r2
 800108a:	fbb0 f0f3 	udiv	r0, r0, r3
 800108e:	4770      	bx	lr
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8001090:	4803      	ldr	r0, [pc, #12]	; (80010a0 <HAL_RCC_GetSysClockFreq+0x88>)
      sysclockfreq = (32768 * (1 << (msiclkrange + 1)));
      break;
    }
  }
  return sysclockfreq;
}
 8001092:	4770      	bx	lr
 8001094:	40023800 	.word	0x40023800
 8001098:	016e3600 	.word	0x016e3600
 800109c:	08002114 	.word	0x08002114
 80010a0:	00f42400 	.word	0x00f42400

080010a4 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80010a4:	4b5f      	ldr	r3, [pc, #380]	; (8001224 <HAL_RCC_ClockConfig+0x180>)
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80010a6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80010aa:	681a      	ldr	r2, [r3, #0]
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80010ac:	4606      	mov	r6, r0
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80010ae:	f002 0201 	and.w	r2, r2, #1
 80010b2:	428a      	cmp	r2, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80010b4:	460d      	mov	r5, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80010b6:	d30a      	bcc.n	80010ce <HAL_RCC_ClockConfig+0x2a>
      return HAL_ERROR;
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80010b8:	6831      	ldr	r1, [r6, #0]
 80010ba:	078b      	lsls	r3, r1, #30
 80010bc:	d51a      	bpl.n	80010f4 <HAL_RCC_ClockConfig+0x50>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80010be:	485a      	ldr	r0, [pc, #360]	; (8001228 <HAL_RCC_ClockConfig+0x184>)
 80010c0:	6883      	ldr	r3, [r0, #8]
 80010c2:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 80010c6:	68b3      	ldr	r3, [r6, #8]
 80010c8:	4313      	orrs	r3, r2
 80010ca:	6083      	str	r3, [r0, #8]
 80010cc:	e012      	b.n	80010f4 <HAL_RCC_ClockConfig+0x50>

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80010ce:	2901      	cmp	r1, #1
 80010d0:	bf02      	ittt	eq
 80010d2:	681a      	ldreq	r2, [r3, #0]
 80010d4:	f042 0204 	orreq.w	r2, r2, #4
 80010d8:	601a      	streq	r2, [r3, #0]
 80010da:	681a      	ldr	r2, [r3, #0]
 80010dc:	f022 0201 	bic.w	r2, r2, #1
 80010e0:	430a      	orrs	r2, r1
 80010e2:	601a      	str	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80010e4:	681b      	ldr	r3, [r3, #0]
 80010e6:	f003 0301 	and.w	r3, r3, #1
 80010ea:	4299      	cmp	r1, r3
 80010ec:	d0e4      	beq.n	80010b8 <HAL_RCC_ClockConfig+0x14>
    {
      return HAL_ERROR;
 80010ee:	2001      	movs	r0, #1
 80010f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80010f4:	07cf      	lsls	r7, r1, #31
 80010f6:	d406      	bmi.n	8001106 <HAL_RCC_ClockConfig+0x62>
        }
      }
    }
  }    
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 80010f8:	4b4a      	ldr	r3, [pc, #296]	; (8001224 <HAL_RCC_ClockConfig+0x180>)
 80010fa:	681a      	ldr	r2, [r3, #0]
 80010fc:	f002 0201 	and.w	r2, r2, #1
 8001100:	4295      	cmp	r5, r2
 8001102:	d35d      	bcc.n	80011c0 <HAL_RCC_ClockConfig+0x11c>
 8001104:	e063      	b.n	80011ce <HAL_RCC_ClockConfig+0x12a>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001106:	6872      	ldr	r2, [r6, #4]
 8001108:	4947      	ldr	r1, [pc, #284]	; (8001228 <HAL_RCC_ClockConfig+0x184>)
 800110a:	2a02      	cmp	r2, #2
 800110c:	d102      	bne.n	8001114 <HAL_RCC_ClockConfig+0x70>
 800110e:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8001112:	e009      	b.n	8001128 <HAL_RCC_ClockConfig+0x84>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001114:	2a03      	cmp	r2, #3
 8001116:	d102      	bne.n	800111e <HAL_RCC_ClockConfig+0x7a>
 8001118:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800111c:	e004      	b.n	8001128 <HAL_RCC_ClockConfig+0x84>
      {
        return HAL_ERROR;
      }
    }
    /* HSI is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 800111e:	2a01      	cmp	r2, #1
 8001120:	bf0c      	ite	eq
 8001122:	2302      	moveq	r3, #2
 8001124:	f44f 7300 	movne.w	r3, #512	; 0x200
 8001128:	fa93 f0a3 	rbit	r0, r3
    }
    /* MSI is selected as System Clock Source */
    else
    {
      /* Check the MSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
 800112c:	6809      	ldr	r1, [r1, #0]
 800112e:	fa93 f3a3 	rbit	r3, r3
 8001132:	fab3 f383 	clz	r3, r3
 8001136:	f003 031f 	and.w	r3, r3, #31
 800113a:	fa21 f303 	lsr.w	r3, r1, r3
 800113e:	07dc      	lsls	r4, r3, #31
 8001140:	d5d5      	bpl.n	80010ee <HAL_RCC_ClockConfig+0x4a>
      {
        return HAL_ERROR;
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001142:	4c39      	ldr	r4, [pc, #228]	; (8001228 <HAL_RCC_ClockConfig+0x184>)
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001144:	f241 3888 	movw	r8, #5000	; 0x1388
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
      {
        return HAL_ERROR;
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001148:	68a3      	ldr	r3, [r4, #8]
 800114a:	f023 0303 	bic.w	r3, r3, #3
 800114e:	431a      	orrs	r2, r3
 8001150:	60a2      	str	r2, [r4, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8001152:	f7ff fa79 	bl	8000648 <HAL_GetTick>
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001156:	6873      	ldr	r3, [r6, #4]
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8001158:	4607      	mov	r7, r0
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800115a:	2b02      	cmp	r3, #2
 800115c:	d10c      	bne.n	8001178 <HAL_RCC_ClockConfig+0xd4>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800115e:	68a3      	ldr	r3, [r4, #8]
 8001160:	f003 030c 	and.w	r3, r3, #12
 8001164:	2b08      	cmp	r3, #8
 8001166:	d0c7      	beq.n	80010f8 <HAL_RCC_ClockConfig+0x54>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001168:	f7ff fa6e 	bl	8000648 <HAL_GetTick>
 800116c:	1bc0      	subs	r0, r0, r7
 800116e:	4540      	cmp	r0, r8
 8001170:	d9f5      	bls.n	800115e <HAL_RCC_ClockConfig+0xba>
        {
          return HAL_TIMEOUT;
 8001172:	2003      	movs	r0, #3
 8001174:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001178:	2b03      	cmp	r3, #3
 800117a:	d10a      	bne.n	8001192 <HAL_RCC_ClockConfig+0xee>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800117c:	68a3      	ldr	r3, [r4, #8]
 800117e:	f003 030c 	and.w	r3, r3, #12
 8001182:	2b0c      	cmp	r3, #12
 8001184:	d0b8      	beq.n	80010f8 <HAL_RCC_ClockConfig+0x54>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001186:	f7ff fa5f 	bl	8000648 <HAL_GetTick>
 800118a:	1bc0      	subs	r0, r0, r7
 800118c:	4540      	cmp	r0, r8
 800118e:	d9f5      	bls.n	800117c <HAL_RCC_ClockConfig+0xd8>
 8001190:	e7ef      	b.n	8001172 <HAL_RCC_ClockConfig+0xce>
        {
          return HAL_TIMEOUT;
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8001192:	2b01      	cmp	r3, #1
 8001194:	d10f      	bne.n	80011b6 <HAL_RCC_ClockConfig+0x112>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8001196:	68a3      	ldr	r3, [r4, #8]
 8001198:	f003 030c 	and.w	r3, r3, #12
 800119c:	2b04      	cmp	r3, #4
 800119e:	d0ab      	beq.n	80010f8 <HAL_RCC_ClockConfig+0x54>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80011a0:	f7ff fa52 	bl	8000648 <HAL_GetTick>
 80011a4:	1bc0      	subs	r0, r0, r7
 80011a6:	4540      	cmp	r0, r8
 80011a8:	d9f5      	bls.n	8001196 <HAL_RCC_ClockConfig+0xf2>
 80011aa:	e7e2      	b.n	8001172 <HAL_RCC_ClockConfig+0xce>
    }      
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80011ac:	f7ff fa4c 	bl	8000648 <HAL_GetTick>
 80011b0:	1bc0      	subs	r0, r0, r7
 80011b2:	4540      	cmp	r0, r8
 80011b4:	d8dd      	bhi.n	8001172 <HAL_RCC_ClockConfig+0xce>
        }
      }
    }      
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 80011b6:	68a3      	ldr	r3, [r4, #8]
 80011b8:	f013 0f0c 	tst.w	r3, #12
 80011bc:	d1f6      	bne.n	80011ac <HAL_RCC_ClockConfig+0x108>
 80011be:	e79b      	b.n	80010f8 <HAL_RCC_ClockConfig+0x54>
  }    
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80011c0:	681a      	ldr	r2, [r3, #0]
 80011c2:	f022 0201 	bic.w	r2, r2, #1
 80011c6:	601a      	str	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80011c8:	681b      	ldr	r3, [r3, #0]
 80011ca:	07da      	lsls	r2, r3, #31
 80011cc:	d48f      	bmi.n	80010ee <HAL_RCC_ClockConfig+0x4a>
      return HAL_ERROR;
    }
  }    

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80011ce:	6831      	ldr	r1, [r6, #0]
 80011d0:	0748      	lsls	r0, r1, #29
 80011d2:	d506      	bpl.n	80011e2 <HAL_RCC_ClockConfig+0x13e>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80011d4:	4814      	ldr	r0, [pc, #80]	; (8001228 <HAL_RCC_ClockConfig+0x184>)
 80011d6:	6883      	ldr	r3, [r0, #8]
 80011d8:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 80011dc:	68f3      	ldr	r3, [r6, #12]
 80011de:	4313      	orrs	r3, r2
 80011e0:	6083      	str	r3, [r0, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80011e2:	070b      	lsls	r3, r1, #28
 80011e4:	d507      	bpl.n	80011f6 <HAL_RCC_ClockConfig+0x152>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 80011e6:	4a10      	ldr	r2, [pc, #64]	; (8001228 <HAL_RCC_ClockConfig+0x184>)
 80011e8:	6931      	ldr	r1, [r6, #16]
 80011ea:	6893      	ldr	r3, [r2, #8]
 80011ec:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 80011f0:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80011f4:	6093      	str	r3, [r2, #8]
  }
 
  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 80011f6:	f7ff ff0f 	bl	8001018 <HAL_RCC_GetSysClockFreq>
 80011fa:	4b0b      	ldr	r3, [pc, #44]	; (8001228 <HAL_RCC_ClockConfig+0x184>)
 80011fc:	22f0      	movs	r2, #240	; 0xf0
 80011fe:	689b      	ldr	r3, [r3, #8]
 8001200:	fa92 f2a2 	rbit	r2, r2
 8001204:	fab2 f282 	clz	r2, r2
 8001208:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800120c:	40d3      	lsrs	r3, r2
 800120e:	4a07      	ldr	r2, [pc, #28]	; (800122c <HAL_RCC_ClockConfig+0x188>)
 8001210:	5cd3      	ldrb	r3, [r2, r3]
 8001212:	40d8      	lsrs	r0, r3
 8001214:	4b06      	ldr	r3, [pc, #24]	; (8001230 <HAL_RCC_ClockConfig+0x18c>)
 8001216:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8001218:	2000      	movs	r0, #0
 800121a:	f7ff f9ed 	bl	80005f8 <HAL_InitTick>
  
  return HAL_OK;
 800121e:	2000      	movs	r0, #0
}
 8001220:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001224:	40023c00 	.word	0x40023c00
 8001228:	40023800 	.word	0x40023800
 800122c:	080020fc 	.word	0x080020fc
 8001230:	20000004 	.word	0x20000004

08001234 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8001234:	4b01      	ldr	r3, [pc, #4]	; (800123c <HAL_RCC_GetHCLKFreq+0x8>)
 8001236:	6818      	ldr	r0, [r3, #0]
 8001238:	4770      	bx	lr
 800123a:	bf00      	nop
 800123c:	20000004 	.word	0x20000004

08001240 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_BITNUMBER]);
 8001240:	4b08      	ldr	r3, [pc, #32]	; (8001264 <HAL_RCC_GetPCLK1Freq+0x24>)
 8001242:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 8001246:	689b      	ldr	r3, [r3, #8]
 8001248:	fa92 f2a2 	rbit	r2, r2
 800124c:	fab2 f282 	clz	r2, r2
 8001250:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8001254:	40d3      	lsrs	r3, r2
 8001256:	4a04      	ldr	r2, [pc, #16]	; (8001268 <HAL_RCC_GetPCLK1Freq+0x28>)
 8001258:	5cd3      	ldrb	r3, [r2, r3]
 800125a:	4a04      	ldr	r2, [pc, #16]	; (800126c <HAL_RCC_GetPCLK1Freq+0x2c>)
 800125c:	6810      	ldr	r0, [r2, #0]
}    
 800125e:	40d8      	lsrs	r0, r3
 8001260:	4770      	bx	lr
 8001262:	bf00      	nop
 8001264:	40023800 	.word	0x40023800
 8001268:	0800210c 	.word	0x0800210c
 800126c:	20000004 	.word	0x20000004

08001270 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_BITNUMBER]);
 8001270:	4b08      	ldr	r3, [pc, #32]	; (8001294 <HAL_RCC_GetPCLK2Freq+0x24>)
 8001272:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001276:	689b      	ldr	r3, [r3, #8]
 8001278:	fa92 f2a2 	rbit	r2, r2
 800127c:	fab2 f282 	clz	r2, r2
 8001280:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 8001284:	40d3      	lsrs	r3, r2
 8001286:	4a04      	ldr	r2, [pc, #16]	; (8001298 <HAL_RCC_GetPCLK2Freq+0x28>)
 8001288:	5cd3      	ldrb	r3, [r2, r3]
 800128a:	4a04      	ldr	r2, [pc, #16]	; (800129c <HAL_RCC_GetPCLK2Freq+0x2c>)
 800128c:	6810      	ldr	r0, [r2, #0]
} 
 800128e:	40d8      	lsrs	r0, r3
 8001290:	4770      	bx	lr
 8001292:	bf00      	nop
 8001294:	40023800 	.word	0x40023800
 8001298:	0800210c 	.word	0x0800210c
 800129c:	20000004 	.word	0x20000004

080012a0 <SPI_WaitOnFlagUntilTimeout>:
  * @param  Status: Flag status to check: RESET or set
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(struct __SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus Status, uint32_t Timeout)  
{
 80012a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80012a4:	4604      	mov	r4, r0
 80012a6:	460e      	mov	r6, r1
 80012a8:	4690      	mov	r8, r2
 80012aa:	461d      	mov	r5, r3
  uint32_t tickstart = 0;

  /* Get tick */ 
  tickstart = HAL_GetTick();
 80012ac:	f7ff f9cc 	bl	8000648 <HAL_GetTick>
 80012b0:	4607      	mov	r7, r0

  /* Wait until flag is set */
  if(Status == RESET)
 80012b2:	f1b8 0f00 	cmp.w	r8, #0
 80012b6:	d13a      	bne.n	800132e <SPI_WaitOnFlagUntilTimeout+0x8e>
  {
    while(__HAL_SPI_GET_FLAG(hspi, Flag) == RESET)
 80012b8:	6822      	ldr	r2, [r4, #0]
 80012ba:	6893      	ldr	r3, [r2, #8]
 80012bc:	ea36 0303 	bics.w	r3, r6, r3
 80012c0:	d00e      	beq.n	80012e0 <SPI_WaitOnFlagUntilTimeout+0x40>
    {
      if(Timeout != HAL_MAX_DELAY)
 80012c2:	1c69      	adds	r1, r5, #1
 80012c4:	d0f9      	beq.n	80012ba <SPI_WaitOnFlagUntilTimeout+0x1a>
      {
        if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
 80012c6:	b17d      	cbz	r5, 80012e8 <SPI_WaitOnFlagUntilTimeout+0x48>
 80012c8:	f7ff f9be 	bl	8000648 <HAL_GetTick>
 80012cc:	1bc0      	subs	r0, r0, r7
 80012ce:	4285      	cmp	r5, r0
 80012d0:	d2f2      	bcs.n	80012b8 <SPI_WaitOnFlagUntilTimeout+0x18>
 80012d2:	e009      	b.n	80012e8 <SPI_WaitOnFlagUntilTimeout+0x48>
  }
  else
  {
    while(__HAL_SPI_GET_FLAG(hspi, Flag) != RESET)
    {
      if(Timeout != HAL_MAX_DELAY)
 80012d4:	1c6b      	adds	r3, r5, #1
 80012d6:	d106      	bne.n	80012e6 <SPI_WaitOnFlagUntilTimeout+0x46>
      }
    }
  }
  else
  {
    while(__HAL_SPI_GET_FLAG(hspi, Flag) != RESET)
 80012d8:	6893      	ldr	r3, [r2, #8]
 80012da:	ea36 0303 	bics.w	r3, r6, r3
 80012de:	d0f9      	beq.n	80012d4 <SPI_WaitOnFlagUntilTimeout+0x34>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 80012e0:	2000      	movs	r0, #0
 80012e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  {
    while(__HAL_SPI_GET_FLAG(hspi, Flag) != RESET)
    {
      if(Timeout != HAL_MAX_DELAY)
      {
        if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
 80012e6:	b9ed      	cbnz	r5, 8001324 <SPI_WaitOnFlagUntilTimeout+0x84>
          /* Disable the SPI and reset the CRC: the CRC value should be cleared
             on both master and slave sides in order to resynchronize the master
             and slave for their respective CRC calculation */

          /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
          __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80012e8:	6823      	ldr	r3, [r4, #0]
 80012ea:	685a      	ldr	r2, [r3, #4]
 80012ec:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 80012f0:	605a      	str	r2, [r3, #4]

          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 80012f2:	681a      	ldr	r2, [r3, #0]
 80012f4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80012f8:	601a      	str	r2, [r3, #0]

          /* Reset CRC Calculation */
          if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80012fa:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80012fc:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8001300:	d107      	bne.n	8001312 <SPI_WaitOnFlagUntilTimeout+0x72>
          {
            SPI_RESET_CRC(hspi);
 8001302:	681a      	ldr	r2, [r3, #0]
 8001304:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8001308:	601a      	str	r2, [r3, #0]
 800130a:	681a      	ldr	r2, [r3, #0]
 800130c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001310:	601a      	str	r2, [r3, #0]
          }

          hspi->State= HAL_SPI_STATE_READY;
 8001312:	2301      	movs	r3, #1
 8001314:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

          /* Process Unlocked */
          __HAL_UNLOCK(hspi);
 8001318:	2300      	movs	r3, #0
 800131a:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50

          return HAL_TIMEOUT;
 800131e:	2003      	movs	r0, #3
 8001320:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  {
    while(__HAL_SPI_GET_FLAG(hspi, Flag) != RESET)
    {
      if(Timeout != HAL_MAX_DELAY)
      {
        if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
 8001324:	f7ff f990 	bl	8000648 <HAL_GetTick>
 8001328:	1bc0      	subs	r0, r0, r7
 800132a:	4285      	cmp	r5, r0
 800132c:	d3dc      	bcc.n	80012e8 <SPI_WaitOnFlagUntilTimeout+0x48>
      }
    }
  }
  else
  {
    while(__HAL_SPI_GET_FLAG(hspi, Flag) != RESET)
 800132e:	6822      	ldr	r2, [r4, #0]
 8001330:	e7d2      	b.n	80012d8 <SPI_WaitOnFlagUntilTimeout+0x38>

08001332 <HAL_SPI_TransmitReceive>:
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
{
 8001332:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8001334:	4604      	mov	r4, r0
  __IO uint16_t tmpreg = 0;
 8001336:	2000      	movs	r0, #0
 8001338:	f8ad 0006 	strh.w	r0, [sp, #6]

  if((hspi->State == HAL_SPI_STATE_READY) || (hspi->State == HAL_SPI_STATE_BUSY_RX))
 800133c:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
{
 8001340:	9d06      	ldr	r5, [sp, #24]
  __IO uint16_t tmpreg = 0;

  if((hspi->State == HAL_SPI_STATE_READY) || (hspi->State == HAL_SPI_STATE_BUSY_RX))
 8001342:	2801      	cmp	r0, #1
 8001344:	d004      	beq.n	8001350 <HAL_SPI_TransmitReceive+0x1e>
 8001346:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51
 800134a:	2822      	cmp	r0, #34	; 0x22
 800134c:	f040 8150 	bne.w	80015f0 <HAL_SPI_TransmitReceive+0x2be>
  {
    if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
 8001350:	2900      	cmp	r1, #0
 8001352:	f000 814b 	beq.w	80015ec <HAL_SPI_TransmitReceive+0x2ba>
 8001356:	2a00      	cmp	r2, #0
 8001358:	f000 8148 	beq.w	80015ec <HAL_SPI_TransmitReceive+0x2ba>
 800135c:	2b00      	cmp	r3, #0
 800135e:	f000 8145 	beq.w	80015ec <HAL_SPI_TransmitReceive+0x2ba>

    /* Check the parameters */
    assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

    /* Process Locked */
    __HAL_LOCK(hspi);
 8001362:	f894 0050 	ldrb.w	r0, [r4, #80]	; 0x50
 8001366:	2801      	cmp	r0, #1
 8001368:	f000 8142 	beq.w	80015f0 <HAL_SPI_TransmitReceive+0x2be>
 800136c:	2001      	movs	r0, #1
 800136e:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
 
    /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
    if(hspi->State == HAL_SPI_STATE_READY)
 8001372:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51

     /* Configure communication */   
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;

    hspi->pRxBuffPtr  = pRxData;
    hspi->RxXferSize  = Size;
 8001376:	87a3      	strh	r3, [r4, #60]	; 0x3c

    /* Process Locked */
    __HAL_LOCK(hspi);
 
    /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
    if(hspi->State == HAL_SPI_STATE_READY)
 8001378:	2801      	cmp	r0, #1
    {
      hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 800137a:	bf04      	itt	eq
 800137c:	2032      	moveq	r0, #50	; 0x32
 800137e:	f884 0051 	strbeq.w	r0, [r4, #81]	; 0x51
    }

     /* Configure communication */   
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001382:	2000      	movs	r0, #0
 8001384:	6560      	str	r0, [r4, #84]	; 0x54
    hspi->pTxBuffPtr  = pTxData;
    hspi->TxXferSize  = Size; 
    hspi->TxXferCount = Size;

    /*Init field not used in handle to zero */
    hspi->RxISR = 0;
 8001386:	64a0      	str	r0, [r4, #72]	; 0x48
    hspi->TxISR = 0;
 8001388:	64e0      	str	r0, [r4, #76]	; 0x4c

    /* Reset CRC Calculation */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800138a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
     /* Configure communication */   
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;

    hspi->pRxBuffPtr  = pRxData;
    hspi->RxXferSize  = Size;
    hspi->RxXferCount = Size;  
 800138c:	87e3      	strh	r3, [r4, #62]	; 0x3e
    /*Init field not used in handle to zero */
    hspi->RxISR = 0;
    hspi->TxISR = 0;

    /* Reset CRC Calculation */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800138e:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
    hspi->pRxBuffPtr  = pRxData;
    hspi->RxXferSize  = Size;
    hspi->RxXferCount = Size;  
    
    hspi->pTxBuffPtr  = pTxData;
    hspi->TxXferSize  = Size; 
 8001392:	86a3      	strh	r3, [r4, #52]	; 0x34
    hspi->TxXferCount = Size;
 8001394:	86e3      	strh	r3, [r4, #54]	; 0x36
    }

     /* Configure communication */   
    hspi->ErrorCode   = HAL_SPI_ERROR_NONE;

    hspi->pRxBuffPtr  = pRxData;
 8001396:	63a2      	str	r2, [r4, #56]	; 0x38
    hspi->RxXferSize  = Size;
    hspi->RxXferCount = Size;  
    
    hspi->pTxBuffPtr  = pTxData;
 8001398:	6321      	str	r1, [r4, #48]	; 0x30
 800139a:	6823      	ldr	r3, [r4, #0]
    /*Init field not used in handle to zero */
    hspi->RxISR = 0;
    hspi->TxISR = 0;

    /* Reset CRC Calculation */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800139c:	d107      	bne.n	80013ae <HAL_SPI_TransmitReceive+0x7c>
    {
      SPI_RESET_CRC(hspi);
 800139e:	681a      	ldr	r2, [r3, #0]
 80013a0:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80013a4:	601a      	str	r2, [r3, #0]
 80013a6:	681a      	ldr	r2, [r3, #0]
 80013a8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80013ac:	601a      	str	r2, [r3, #0]
    }

    /* Check if the SPI is already enabled */ 
    if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 80013ae:	681a      	ldr	r2, [r3, #0]
 80013b0:	0652      	lsls	r2, r2, #25
    {
      /* Enable SPI peripheral */
      __HAL_SPI_ENABLE(hspi);
 80013b2:	bf5e      	ittt	pl
 80013b4:	681a      	ldrpl	r2, [r3, #0]
 80013b6:	f042 0240 	orrpl.w	r2, r2, #64	; 0x40
 80013ba:	601a      	strpl	r2, [r3, #0]
    }

    /* Transmit and Receive data in 16 Bit mode */
    if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 80013bc:	68e2      	ldr	r2, [r4, #12]
 80013be:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 80013c2:	6862      	ldr	r2, [r4, #4]
 80013c4:	d164      	bne.n	8001490 <HAL_SPI_TransmitReceive+0x15e>
    {
      if((hspi->Init.Mode == SPI_MODE_SLAVE) || ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->TxXferCount == 0x01)))
 80013c6:	b132      	cbz	r2, 80013d6 <HAL_SPI_TransmitReceive+0xa4>
 80013c8:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 80013cc:	d10b      	bne.n	80013e6 <HAL_SPI_TransmitReceive+0xb4>
 80013ce:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 80013d0:	b292      	uxth	r2, r2
 80013d2:	2a01      	cmp	r2, #1
 80013d4:	d107      	bne.n	80013e6 <HAL_SPI_TransmitReceive+0xb4>
      {
        hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 80013d6:	f831 2b02 	ldrh.w	r2, [r1], #2
 80013da:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr+=2;
        hspi->TxXferCount--;
 80013dc:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
    if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
    {
      if((hspi->Init.Mode == SPI_MODE_SLAVE) || ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->TxXferCount == 0x01)))
      {
        hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
        hspi->pTxBuffPtr+=2;
 80013de:	6321      	str	r1, [r4, #48]	; 0x30
        hspi->TxXferCount--;
 80013e0:	3a01      	subs	r2, #1
 80013e2:	b292      	uxth	r2, r2
 80013e4:	86e2      	strh	r2, [r4, #54]	; 0x36
      }
      if(hspi->TxXferCount == 0)
 80013e6:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 80013e8:	b292      	uxth	r2, r2
 80013ea:	2a00      	cmp	r2, #0
 80013ec:	d13a      	bne.n	8001464 <HAL_SPI_TransmitReceive+0x132>
      {
        /* Enable CRC Transmission */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80013ee:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
        {
          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 80013f2:	bf02      	ittt	eq
 80013f4:	681a      	ldreq	r2, [r3, #0]
 80013f6:	f442 5280 	orreq.w	r2, r2, #4096	; 0x1000
 80013fa:	601a      	streq	r2, [r3, #0]
        }

        /* Wait until RXNE flag is set */
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 80013fc:	462b      	mov	r3, r5
 80013fe:	2200      	movs	r2, #0
 8001400:	e038      	b.n	8001474 <HAL_SPI_TransmitReceive+0x142>
      else
      {
        while(hspi->TxXferCount > 0)
        {
          /* Wait until TXE flag is set to send data */
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8001402:	462b      	mov	r3, r5
 8001404:	2200      	movs	r2, #0
 8001406:	2102      	movs	r1, #2
 8001408:	4620      	mov	r0, r4
 800140a:	f7ff ff49 	bl	80012a0 <SPI_WaitOnFlagUntilTimeout>
 800140e:	2800      	cmp	r0, #0
 8001410:	f040 80cb 	bne.w	80015aa <HAL_SPI_TransmitReceive+0x278>
          { 
            return HAL_TIMEOUT;
          }

          hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
 8001414:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001416:	6822      	ldr	r2, [r4, #0]
 8001418:	f833 1b02 	ldrh.w	r1, [r3], #2
 800141c:	60d1      	str	r1, [r2, #12]
          hspi->pTxBuffPtr+=2;
 800141e:	6323      	str	r3, [r4, #48]	; 0x30
          hspi->TxXferCount--;
 8001420:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8001422:	3b01      	subs	r3, #1
 8001424:	b29b      	uxth	r3, r3
 8001426:	86e3      	strh	r3, [r4, #54]	; 0x36

          /* Enable CRC Transmission */
          if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 8001428:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800142a:	b29b      	uxth	r3, r3
 800142c:	b93b      	cbnz	r3, 800143e <HAL_SPI_TransmitReceive+0x10c>
 800142e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001430:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
          {
            SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 8001434:	bf02      	ittt	eq
 8001436:	6813      	ldreq	r3, [r2, #0]
 8001438:	f443 5380 	orreq.w	r3, r3, #4096	; 0x1000
 800143c:	6013      	streq	r3, [r2, #0]
          }

          /* Wait until RXNE flag is set */
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 800143e:	462b      	mov	r3, r5
 8001440:	2200      	movs	r2, #0
 8001442:	2101      	movs	r1, #1
 8001444:	4620      	mov	r0, r4
 8001446:	f7ff ff2b 	bl	80012a0 <SPI_WaitOnFlagUntilTimeout>
 800144a:	2800      	cmp	r0, #0
 800144c:	f040 80ad 	bne.w	80015aa <HAL_SPI_TransmitReceive+0x278>
          { 
            return HAL_TIMEOUT;
          }

          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8001450:	6823      	ldr	r3, [r4, #0]
 8001452:	68da      	ldr	r2, [r3, #12]
 8001454:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001456:	f823 2b02 	strh.w	r2, [r3], #2
          hspi->pRxBuffPtr+=2;
 800145a:	63a3      	str	r3, [r4, #56]	; 0x38
          hspi->RxXferCount--;
 800145c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800145e:	3b01      	subs	r3, #1
 8001460:	b29b      	uxth	r3, r3
 8001462:	87e3      	strh	r3, [r4, #62]	; 0x3e
        hspi->pRxBuffPtr+=2;
        hspi->RxXferCount--;
      }
      else
      {
        while(hspi->TxXferCount > 0)
 8001464:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8001466:	b29b      	uxth	r3, r3
 8001468:	2b00      	cmp	r3, #0
 800146a:	d1ca      	bne.n	8001402 <HAL_SPI_TransmitReceive+0xd0>
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
          hspi->pRxBuffPtr+=2;
          hspi->RxXferCount--;
        }
        /* Receive the last byte */
        if(hspi->Init.Mode == SPI_MODE_SLAVE)
 800146c:	6862      	ldr	r2, [r4, #4]
 800146e:	2a00      	cmp	r2, #0
 8001470:	d17a      	bne.n	8001568 <HAL_SPI_TransmitReceive+0x236>
        {
          /* Wait until RXNE flag is set */
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8001472:	462b      	mov	r3, r5
 8001474:	2101      	movs	r1, #1
 8001476:	4620      	mov	r0, r4
 8001478:	f7ff ff12 	bl	80012a0 <SPI_WaitOnFlagUntilTimeout>
 800147c:	2800      	cmp	r0, #0
 800147e:	f040 8094 	bne.w	80015aa <HAL_SPI_TransmitReceive+0x278>
          {
            return HAL_TIMEOUT;
          }
          
          *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8001482:	6823      	ldr	r3, [r4, #0]
 8001484:	68da      	ldr	r2, [r3, #12]
 8001486:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001488:	f823 2b02 	strh.w	r2, [r3], #2
          hspi->pRxBuffPtr+=2;
 800148c:	63a3      	str	r3, [r4, #56]	; 0x38
 800148e:	e067      	b.n	8001560 <HAL_SPI_TransmitReceive+0x22e>
      }
    }
    /* Transmit and Receive data in 8 Bit mode */
    else
    {
      if((hspi->Init.Mode == SPI_MODE_SLAVE) || ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->TxXferCount == 0x01)))
 8001490:	b132      	cbz	r2, 80014a0 <HAL_SPI_TransmitReceive+0x16e>
 8001492:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 8001496:	d10b      	bne.n	80014b0 <HAL_SPI_TransmitReceive+0x17e>
 8001498:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 800149a:	b292      	uxth	r2, r2
 800149c:	2a01      	cmp	r2, #1
 800149e:	d107      	bne.n	80014b0 <HAL_SPI_TransmitReceive+0x17e>
      {
        hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 80014a0:	1c4a      	adds	r2, r1, #1
 80014a2:	6322      	str	r2, [r4, #48]	; 0x30
 80014a4:	780a      	ldrb	r2, [r1, #0]
 80014a6:	60da      	str	r2, [r3, #12]
        hspi->TxXferCount--;
 80014a8:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 80014aa:	3a01      	subs	r2, #1
 80014ac:	b292      	uxth	r2, r2
 80014ae:	86e2      	strh	r2, [r4, #54]	; 0x36
      }
      if(hspi->TxXferCount == 0)
 80014b0:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 80014b2:	b292      	uxth	r2, r2
 80014b4:	2a00      	cmp	r2, #0
 80014b6:	d141      	bne.n	800153c <HAL_SPI_TransmitReceive+0x20a>
      {
        /* Enable CRC Transmission */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80014b8:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
        {
          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 80014bc:	bf08      	it	eq
 80014be:	681a      	ldreq	r2, [r3, #0]
        }

        /* Wait until RXNE flag is set */
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 80014c0:	f04f 0101 	mov.w	r1, #1
      if(hspi->TxXferCount == 0)
      {
        /* Enable CRC Transmission */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
        {
          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 80014c4:	bf04      	itt	eq
 80014c6:	f442 5280 	orreq.w	r2, r2, #4096	; 0x1000
 80014ca:	601a      	streq	r2, [r3, #0]
        }

        /* Wait until RXNE flag is set */
        if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 80014cc:	4620      	mov	r0, r4
 80014ce:	462b      	mov	r3, r5
 80014d0:	2200      	movs	r2, #0
 80014d2:	f7ff fee5 	bl	80012a0 <SPI_WaitOnFlagUntilTimeout>
 80014d6:	2800      	cmp	r0, #0
 80014d8:	d167      	bne.n	80015aa <HAL_SPI_TransmitReceive+0x278>
        {
          return HAL_TIMEOUT;
        }

        (*hspi->pRxBuffPtr) = hspi->Instance->DR;
 80014da:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80014dc:	e03d      	b.n	800155a <HAL_SPI_TransmitReceive+0x228>
      else
      {
        while(hspi->TxXferCount > 0)
        {
          /* Wait until TXE flag is set to send data */
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
 80014de:	462b      	mov	r3, r5
 80014e0:	2200      	movs	r2, #0
 80014e2:	2102      	movs	r1, #2
 80014e4:	4620      	mov	r0, r4
 80014e6:	f7ff fedb 	bl	80012a0 <SPI_WaitOnFlagUntilTimeout>
 80014ea:	2800      	cmp	r0, #0
 80014ec:	d15d      	bne.n	80015aa <HAL_SPI_TransmitReceive+0x278>
          {
            return HAL_TIMEOUT;
          }

          hspi->Instance->DR = (*hspi->pTxBuffPtr++);
 80014ee:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80014f0:	6822      	ldr	r2, [r4, #0]
 80014f2:	1c59      	adds	r1, r3, #1
 80014f4:	6321      	str	r1, [r4, #48]	; 0x30
 80014f6:	781b      	ldrb	r3, [r3, #0]
 80014f8:	60d3      	str	r3, [r2, #12]
          hspi->TxXferCount--;
 80014fa:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80014fc:	3b01      	subs	r3, #1
 80014fe:	b29b      	uxth	r3, r3
 8001500:	86e3      	strh	r3, [r4, #54]	; 0x36

          /* Enable CRC Transmission */
          if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 8001502:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8001504:	b29b      	uxth	r3, r3
 8001506:	b93b      	cbnz	r3, 8001518 <HAL_SPI_TransmitReceive+0x1e6>
 8001508:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800150a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
          {
            SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 800150e:	bf02      	ittt	eq
 8001510:	6813      	ldreq	r3, [r2, #0]
 8001512:	f443 5380 	orreq.w	r3, r3, #4096	; 0x1000
 8001516:	6013      	streq	r3, [r2, #0]
          }

          /* Wait until RXNE flag is set */
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8001518:	462b      	mov	r3, r5
 800151a:	2200      	movs	r2, #0
 800151c:	2101      	movs	r1, #1
 800151e:	4620      	mov	r0, r4
 8001520:	f7ff febe 	bl	80012a0 <SPI_WaitOnFlagUntilTimeout>
 8001524:	2800      	cmp	r0, #0
 8001526:	d140      	bne.n	80015aa <HAL_SPI_TransmitReceive+0x278>
          {
            return HAL_TIMEOUT;
          }

          (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
 8001528:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800152a:	1c5a      	adds	r2, r3, #1
 800152c:	63a2      	str	r2, [r4, #56]	; 0x38
 800152e:	6822      	ldr	r2, [r4, #0]
 8001530:	68d2      	ldr	r2, [r2, #12]
 8001532:	701a      	strb	r2, [r3, #0]
          hspi->RxXferCount--;
 8001534:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001536:	3b01      	subs	r3, #1
 8001538:	b29b      	uxth	r3, r3
 800153a:	87e3      	strh	r3, [r4, #62]	; 0x3e
        (*hspi->pRxBuffPtr) = hspi->Instance->DR;
        hspi->RxXferCount--;
      }
      else
      {
        while(hspi->TxXferCount > 0)
 800153c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800153e:	b29b      	uxth	r3, r3
 8001540:	2b00      	cmp	r3, #0
 8001542:	d1cc      	bne.n	80014de <HAL_SPI_TransmitReceive+0x1ac>
          }

          (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
          hspi->RxXferCount--;
        }
        if(hspi->Init.Mode == SPI_MODE_SLAVE)
 8001544:	6862      	ldr	r2, [r4, #4]
 8001546:	b97a      	cbnz	r2, 8001568 <HAL_SPI_TransmitReceive+0x236>
        {
          /* Wait until RXNE flag is set */
          if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8001548:	462b      	mov	r3, r5
 800154a:	2101      	movs	r1, #1
 800154c:	4620      	mov	r0, r4
 800154e:	f7ff fea7 	bl	80012a0 <SPI_WaitOnFlagUntilTimeout>
 8001552:	bb50      	cbnz	r0, 80015aa <HAL_SPI_TransmitReceive+0x278>
          {
            return HAL_TIMEOUT;
          }
          
          (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
 8001554:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001556:	1c5a      	adds	r2, r3, #1
 8001558:	63a2      	str	r2, [r4, #56]	; 0x38
 800155a:	6822      	ldr	r2, [r4, #0]
 800155c:	68d2      	ldr	r2, [r2, #12]
 800155e:	701a      	strb	r2, [r3, #0]
          hspi->RxXferCount--;
 8001560:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001562:	3b01      	subs	r3, #1
 8001564:	b29b      	uxth	r3, r3
 8001566:	87e3      	strh	r3, [r4, #62]	; 0x3e
        }
      }
    }

    /* Read CRC from DR to close CRC calculation process */
    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8001568:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800156a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800156e:	d111      	bne.n	8001594 <HAL_SPI_TransmitReceive+0x262>
    {
      /* Wait until RXNE flag is set */
      if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
 8001570:	462b      	mov	r3, r5
 8001572:	2200      	movs	r2, #0
 8001574:	2101      	movs	r1, #1
 8001576:	4620      	mov	r0, r4
 8001578:	f7ff fe92 	bl	80012a0 <SPI_WaitOnFlagUntilTimeout>
 800157c:	b118      	cbz	r0, 8001586 <HAL_SPI_TransmitReceive+0x254>
      {
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 800157e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001580:	f043 0302 	orr.w	r3, r3, #2
 8001584:	e010      	b.n	80015a8 <HAL_SPI_TransmitReceive+0x276>
        return HAL_TIMEOUT;
      }
      /* Read CRC */
      tmpreg = hspi->Instance->DR;
 8001586:	6823      	ldr	r3, [r4, #0]
 8001588:	68db      	ldr	r3, [r3, #12]
 800158a:	b29b      	uxth	r3, r3
 800158c:	f8ad 3006 	strh.w	r3, [sp, #6]
      UNUSED(tmpreg);
 8001590:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    }

    /* Wait until Busy flag is reset before disabling SPI */
    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, Timeout) != HAL_OK)
 8001594:	462b      	mov	r3, r5
 8001596:	2201      	movs	r2, #1
 8001598:	2180      	movs	r1, #128	; 0x80
 800159a:	4620      	mov	r0, r4
 800159c:	f7ff fe80 	bl	80012a0 <SPI_WaitOnFlagUntilTimeout>
 80015a0:	b128      	cbz	r0, 80015ae <HAL_SPI_TransmitReceive+0x27c>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80015a2:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80015a4:	f043 0320 	orr.w	r3, r3, #32
 80015a8:	6563      	str	r3, [r4, #84]	; 0x54
      return HAL_TIMEOUT;
 80015aa:	2003      	movs	r0, #3
 80015ac:	e021      	b.n	80015f2 <HAL_SPI_TransmitReceive+0x2c0>
    }
    
    hspi->State = HAL_SPI_STATE_READY;

    /* Check if CRC error occurred */
    if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET))
 80015ae:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
      return HAL_TIMEOUT;
    }
    
    hspi->State = HAL_SPI_STATE_READY;
 80015b0:	2101      	movs	r1, #1

    /* Check if CRC error occurred */
    if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET))
 80015b2:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
      return HAL_TIMEOUT;
    }
    
    hspi->State = HAL_SPI_STATE_READY;
 80015b6:	f884 1051 	strb.w	r1, [r4, #81]	; 0x51

    /* Check if CRC error occurred */
    if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET))
 80015ba:	d113      	bne.n	80015e4 <HAL_SPI_TransmitReceive+0x2b2>
 80015bc:	6823      	ldr	r3, [r4, #0]
 80015be:	689a      	ldr	r2, [r3, #8]
 80015c0:	06d2      	lsls	r2, r2, #27
 80015c2:	d50f      	bpl.n	80015e4 <HAL_SPI_TransmitReceive+0x2b2>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 80015c4:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80015c6:	f042 0202 	orr.w	r2, r2, #2
 80015ca:	6562      	str	r2, [r4, #84]	; 0x54

      /* Reset CRC Calculation */
      if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
      {
        SPI_RESET_CRC(hspi);
 80015cc:	681a      	ldr	r2, [r3, #0]
 80015ce:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80015d2:	601a      	str	r2, [r3, #0]
 80015d4:	681a      	ldr	r2, [r3, #0]
 80015d6:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80015da:	601a      	str	r2, [r3, #0]
      }

      /* Process Unlocked */
      __HAL_UNLOCK(hspi);
 80015dc:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
      
      return HAL_ERROR; 
 80015e0:	4608      	mov	r0, r1
 80015e2:	e006      	b.n	80015f2 <HAL_SPI_TransmitReceive+0x2c0>
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hspi);
 80015e4:	2300      	movs	r3, #0
 80015e6:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50

    return HAL_OK;
 80015ea:	e002      	b.n	80015f2 <HAL_SPI_TransmitReceive+0x2c0>

  if((hspi->State == HAL_SPI_STATE_READY) || (hspi->State == HAL_SPI_STATE_BUSY_RX))
  {
    if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
    {
      return  HAL_ERROR;
 80015ec:	2001      	movs	r0, #1
 80015ee:	e000      	b.n	80015f2 <HAL_SPI_TransmitReceive+0x2c0>

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 80015f0:	2002      	movs	r0, #2
  }
}
 80015f2:	b003      	add	sp, #12
 80015f4:	bd30      	pop	{r4, r5, pc}

080015f6 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 80015f6:	b510      	push	{r4, lr}
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 80015f8:	4604      	mov	r4, r0
 80015fa:	2800      	cmp	r0, #0
 80015fc:	d036      	beq.n	800166c <HAL_SPI_Init+0x76>
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
  assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));

  if(hspi->State == HAL_SPI_STATE_RESET)
 80015fe:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 8001602:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001606:	b91b      	cbnz	r3, 8001610 <HAL_SPI_Init+0x1a>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8001608:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 800160c:	f7fe feca 	bl	80003a4 <HAL_SPI_MspInit>
  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 8001610:	68a1      	ldr	r1, [r4, #8]
 8001612:	6860      	ldr	r0, [r4, #4]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }
  
  hspi->State = HAL_SPI_STATE_BUSY;
 8001614:	2302      	movs	r3, #2
  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 8001616:	4308      	orrs	r0, r1
 8001618:	68e1      	ldr	r1, [r4, #12]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }
  
  hspi->State = HAL_SPI_STATE_BUSY;
 800161a:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 800161e:	4308      	orrs	r0, r1
 8001620:	6921      	ldr	r1, [r4, #16]
  }
  
  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disble the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001622:	6823      	ldr	r3, [r4, #0]
  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 8001624:	4308      	orrs	r0, r1
 8001626:	6961      	ldr	r1, [r4, #20]
  }
  
  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disble the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001628:	681a      	ldr	r2, [r3, #0]
  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 800162a:	4308      	orrs	r0, r1
 800162c:	69e1      	ldr	r1, [r4, #28]
  }
  
  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disble the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 800162e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 8001632:	4308      	orrs	r0, r1
 8001634:	6a21      	ldr	r1, [r4, #32]
  }
  
  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disble the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001636:	601a      	str	r2, [r3, #0]
  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 8001638:	4308      	orrs	r0, r1

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
 800163a:	69a2      	ldr	r2, [r4, #24]
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
 800163c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800163e:	4308      	orrs	r0, r1
 8001640:	f402 7100 	and.w	r1, r2, #512	; 0x200
 8001644:	4301      	orrs	r1, r0
  __HAL_SPI_DISABLE(hspi);

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8001646:	6019      	str	r1, [r3, #0]
                         hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                         hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);

  /* Configure : NSS management */
  hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode);
 8001648:	0c12      	lsrs	r2, r2, #16
 800164a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800164c:	f002 0204 	and.w	r2, r2, #4
 8001650:	430a      	orrs	r2, r1
 8001652:	605a      	str	r2, [r3, #4]

  /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
  /* Configure : CRC Polynomial */
  hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
 8001654:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
#if defined (STM32L100xC) || defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC) || defined (STM32L151xCA) || defined (STM32L151xD) || defined (STM32L152xCA) || defined (STM32L152xD) || defined (STM32L162xCA) || defined (STM32L162xD) || defined (STM32L151xE) || defined (STM32L151xDX) || defined (STM32L152xE) || defined (STM32L152xDX) || defined (STM32L162xE) || defined (STM32L162xDX)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8001656:	2000      	movs	r0, #0
  /* Configure : NSS management */
  hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode);

  /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
  /* Configure : CRC Polynomial */
  hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
 8001658:	611a      	str	r2, [r3, #16]

#if defined (STM32L100xC) || defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC) || defined (STM32L151xCA) || defined (STM32L151xD) || defined (STM32L152xCA) || defined (STM32L152xD) || defined (STM32L162xCA) || defined (STM32L162xD) || defined (STM32L151xE) || defined (STM32L151xDX) || defined (STM32L152xE) || defined (STM32L152xDX) || defined (STM32L162xE) || defined (STM32L162xDX)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800165a:	69da      	ldr	r2, [r3, #28]
 800165c:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001660:	61da      	str	r2, [r3, #28]
#endif

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State = HAL_SPI_STATE_READY;
 8001662:	2301      	movs	r3, #1
#if defined (STM32L100xC) || defined (STM32L151xC) || defined (STM32L152xC) || defined (STM32L162xC) || defined (STM32L151xCA) || defined (STM32L151xD) || defined (STM32L152xCA) || defined (STM32L152xD) || defined (STM32L162xCA) || defined (STM32L162xD) || defined (STM32L151xE) || defined (STM32L151xDX) || defined (STM32L152xE) || defined (STM32L152xDX) || defined (STM32L162xE) || defined (STM32L162xDX)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8001664:	6560      	str	r0, [r4, #84]	; 0x54
  hspi->State = HAL_SPI_STATE_READY;
 8001666:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  
  return HAL_OK;
 800166a:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
  /* Check the SPI handle allocation */
  if(hspi == NULL)
  {
    return HAL_ERROR;
 800166c:	2001      	movs	r0, #1

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State = HAL_SPI_STATE_READY;
  
  return HAL_OK;
}
 800166e:	bd10      	pop	{r4, pc}

08001670 <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001670:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  * @retval None
  */
static void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;
 8001674:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001676:	d00e      	beq.n	8001696 <TIM_Base_SetConfig+0x26>
 8001678:	4a1c      	ldr	r2, [pc, #112]	; (80016ec <TIM_Base_SetConfig+0x7c>)
 800167a:	4290      	cmp	r0, r2
 800167c:	d00b      	beq.n	8001696 <TIM_Base_SetConfig+0x26>
 800167e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001682:	4290      	cmp	r0, r2
 8001684:	d007      	beq.n	8001696 <TIM_Base_SetConfig+0x26>
 8001686:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800168a:	4290      	cmp	r0, r2
 800168c:	d003      	beq.n	8001696 <TIM_Base_SetConfig+0x26>
 800168e:	f502 427c 	add.w	r2, r2, #64512	; 0xfc00
 8001692:	4290      	cmp	r0, r2
 8001694:	d116      	bne.n	80016c4 <TIM_Base_SetConfig+0x54>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 8001696:	684a      	ldr	r2, [r1, #4]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8001698:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800169c:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 80016a0:	ea43 0302 	orr.w	r3, r3, r2
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80016a4:	d015      	beq.n	80016d2 <TIM_Base_SetConfig+0x62>
 80016a6:	4a11      	ldr	r2, [pc, #68]	; (80016ec <TIM_Base_SetConfig+0x7c>)
 80016a8:	4290      	cmp	r0, r2
 80016aa:	d012      	beq.n	80016d2 <TIM_Base_SetConfig+0x62>
 80016ac:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80016b0:	4290      	cmp	r0, r2
 80016b2:	d00e      	beq.n	80016d2 <TIM_Base_SetConfig+0x62>
 80016b4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80016b8:	4290      	cmp	r0, r2
 80016ba:	d00a      	beq.n	80016d2 <TIM_Base_SetConfig+0x62>
 80016bc:	f502 427c 	add.w	r2, r2, #64512	; 0xfc00
 80016c0:	4290      	cmp	r0, r2
 80016c2:	d006      	beq.n	80016d2 <TIM_Base_SetConfig+0x62>
 80016c4:	4a0a      	ldr	r2, [pc, #40]	; (80016f0 <TIM_Base_SetConfig+0x80>)
 80016c6:	4290      	cmp	r0, r2
 80016c8:	d003      	beq.n	80016d2 <TIM_Base_SetConfig+0x62>
 80016ca:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80016ce:	4290      	cmp	r0, r2
 80016d0:	d103      	bne.n	80016da <TIM_Base_SetConfig+0x6a>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80016d2:	68ca      	ldr	r2, [r1, #12]
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80016d4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80016d8:	4313      	orrs	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 80016da:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 80016dc:	688b      	ldr	r3, [r1, #8]
 80016de:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 80016e0:	680b      	ldr	r3, [r1, #0]
 80016e2:	6283      	str	r3, [r0, #40]	; 0x28

  /* Generate an update event to reload the Prescaler */
  TIMx->EGR = TIM_EGR_UG;
 80016e4:	2301      	movs	r3, #1
 80016e6:	6143      	str	r3, [r0, #20]
 80016e8:	4770      	bx	lr
 80016ea:	bf00      	nop
 80016ec:	40000400 	.word	0x40000400
 80016f0:	40010c00 	.word	0x40010c00

080016f4 <HAL_TIM_Base_Init>:
  *         parameters in the TIM_HandleTypeDef and create the associated handle.
  * @param  htim: TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 80016f4:	b510      	push	{r4, lr}
  /* Check the TIM handle allocation */
  if(htim == NULL)
 80016f6:	4604      	mov	r4, r0
 80016f8:	b1a0      	cbz	r0, 8001724 <HAL_TIM_Base_Init+0x30>
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));

  if(htim->State == HAL_TIM_STATE_RESET)
 80016fa:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80016fe:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001702:	b91b      	cbnz	r3, 800170c <HAL_TIM_Base_Init+0x18>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8001704:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 8001708:	f7fe fef4 	bl	80004f4 <HAL_TIM_Base_MspInit>
  }

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 800170c:	2302      	movs	r3, #2
 800170e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8001712:	6820      	ldr	r0, [r4, #0]
 8001714:	1d21      	adds	r1, r4, #4
 8001716:	f7ff ffab 	bl	8001670 <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 800171a:	2301      	movs	r3, #1
 800171c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

  return HAL_OK;
 8001720:	2000      	movs	r0, #0
 8001722:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if(htim == NULL)
  {
    return HAL_ERROR;
 8001724:	2001      	movs	r0, #1

  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;

  return HAL_OK;
}
 8001726:	bd10      	pop	{r4, pc}

08001728 <HAL_TIMEx_MasterConfigSynchronization>:
  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  __HAL_LOCK(htim);
 8001728:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
  *         contains the selected trigger output (TRGO) and the Master/Slave
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
{
 800172c:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  __HAL_LOCK(htim);
 800172e:	2b01      	cmp	r3, #1
 8001730:	f04f 0302 	mov.w	r3, #2
 8001734:	d018      	beq.n	8001768 <HAL_TIMEx_MasterConfigSynchronization+0x40>

  htim->State = HAL_TIM_STATE_BUSY;
 8001736:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35

  /* Reset the MMS Bits */
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 800173a:	6803      	ldr	r3, [r0, #0]
 800173c:	685a      	ldr	r2, [r3, #4]
 800173e:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8001742:	605a      	str	r2, [r3, #4]
  /* Select the TRGO source */
  htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
 8001744:	685c      	ldr	r4, [r3, #4]
 8001746:	680a      	ldr	r2, [r1, #0]
 8001748:	4322      	orrs	r2, r4
 800174a:	605a      	str	r2, [r3, #4]

  /* Reset the MSM Bit */
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
 800174c:	689a      	ldr	r2, [r3, #8]
 800174e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001752:	609a      	str	r2, [r3, #8]
  /* Set or Reset the MSM Bit */
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 8001754:	689c      	ldr	r4, [r3, #8]
 8001756:	684a      	ldr	r2, [r1, #4]
 8001758:	4322      	orrs	r2, r4
 800175a:	609a      	str	r2, [r3, #8]

  htim->State = HAL_TIM_STATE_READY;
 800175c:	2301      	movs	r3, #1
 800175e:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35

  __HAL_UNLOCK(htim);
 8001762:	2300      	movs	r3, #0
 8001764:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  __HAL_LOCK(htim);
 8001768:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);

  return HAL_OK;
}
 800176a:	bd10      	pop	{r4, pc}

0800176c <UART_SetConfig>:
  * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 800176c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001770:	4681      	mov	r9, r0
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*------- UART-associated USART registers setting : CR2 Configuration ------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8001772:	6806      	ldr	r6, [r0, #0]
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1, 
 8001774:	f8d9 1008 	ldr.w	r1, [r9, #8]
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*------- UART-associated USART registers setting : CR2 Configuration ------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8001778:	6933      	ldr	r3, [r6, #16]
 800177a:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 800177e:	68c3      	ldr	r3, [r0, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8001780:	69c0      	ldr	r0, [r0, #28]
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*------- UART-associated USART registers setting : CR2 Configuration ------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8001782:	4313      	orrs	r3, r2
 8001784:	6133      	str	r3, [r6, #16]
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1, 
 8001786:	f8d9 3010 	ldr.w	r3, [r9, #16]
 800178a:	68f2      	ldr	r2, [r6, #12]
 800178c:	4319      	orrs	r1, r3
 800178e:	f8d9 3014 	ldr.w	r3, [r9, #20]
  /*------- UART-associated USART registers setting : CR3 Configuration ------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001792:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1, 
 8001796:	ea43 0301 	orr.w	r3, r3, r1
 800179a:	ea43 0100 	orr.w	r1, r3, r0
 800179e:	f422 4316 	bic.w	r3, r2, #38400	; 0x9600
 80017a2:	f023 030c 	bic.w	r3, r3, #12
 80017a6:	ea43 0301 	orr.w	r3, r3, r1
 80017aa:	60f3      	str	r3, [r6, #12]
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8), 
             tmpreg);
  
  /*------- UART-associated USART registers setting : CR3 Configuration ------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 80017ac:	6973      	ldr	r3, [r6, #20]
 80017ae:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 80017b2:	f8d9 3018 	ldr.w	r3, [r9, #24]
 80017b6:	ea43 0302 	orr.w	r3, r3, r2
 80017ba:	6173      	str	r3, [r6, #20]
 80017bc:	4b7d      	ldr	r3, [pc, #500]	; (80019b4 <UART_SetConfig+0x248>)
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80017be:	d17d      	bne.n	80018bc <UART_SetConfig+0x150>
  {
    /*------- UART-associated USART registers setting : BRR Configuration ------*/
    if((huart->Instance == USART1))
 80017c0:	429e      	cmp	r6, r3
 80017c2:	f04f 0419 	mov.w	r4, #25
 80017c6:	d132      	bne.n	800182e <UART_SetConfig+0xc2>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 80017c8:	f7ff fd52 	bl	8001270 <HAL_RCC_GetPCLK2Freq>
 80017cc:	4360      	muls	r0, r4
 80017ce:	f8d9 7004 	ldr.w	r7, [r9, #4]
 80017d2:	f04f 0864 	mov.w	r8, #100	; 0x64
 80017d6:	007f      	lsls	r7, r7, #1
 80017d8:	fbb0 f7f7 	udiv	r7, r0, r7
 80017dc:	f7ff fd48 	bl	8001270 <HAL_RCC_GetPCLK2Freq>
 80017e0:	4360      	muls	r0, r4
 80017e2:	f8d9 5004 	ldr.w	r5, [r9, #4]
 80017e6:	fbb7 f7f8 	udiv	r7, r7, r8
 80017ea:	006d      	lsls	r5, r5, #1
 80017ec:	fbb0 f5f5 	udiv	r5, r0, r5
 80017f0:	f7ff fd3e 	bl	8001270 <HAL_RCC_GetPCLK2Freq>
 80017f4:	4360      	muls	r0, r4
 80017f6:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80017fa:	013f      	lsls	r7, r7, #4
 80017fc:	005b      	lsls	r3, r3, #1
 80017fe:	fbb0 f0f3 	udiv	r0, r0, r3
 8001802:	fbb0 f0f8 	udiv	r0, r0, r8
 8001806:	fb08 5510 	mls	r5, r8, r0, r5
 800180a:	f7ff fd31 	bl	8001270 <HAL_RCC_GetPCLK2Freq>
 800180e:	00ed      	lsls	r5, r5, #3
 8001810:	3532      	adds	r5, #50	; 0x32
 8001812:	fbb5 f5f8 	udiv	r5, r5, r8
 8001816:	4360      	muls	r0, r4
 8001818:	f8d9 1004 	ldr.w	r1, [r9, #4]
 800181c:	006d      	lsls	r5, r5, #1
 800181e:	0049      	lsls	r1, r1, #1
 8001820:	f405 75f8 	and.w	r5, r5, #496	; 0x1f0
 8001824:	fbb0 faf1 	udiv	sl, r0, r1
 8001828:	f7ff fd22 	bl	8001270 <HAL_RCC_GetPCLK2Freq>
 800182c:	e031      	b.n	8001892 <UART_SetConfig+0x126>
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 800182e:	f7ff fd07 	bl	8001240 <HAL_RCC_GetPCLK1Freq>
 8001832:	4360      	muls	r0, r4
 8001834:	f8d9 7004 	ldr.w	r7, [r9, #4]
 8001838:	f04f 0864 	mov.w	r8, #100	; 0x64
 800183c:	007f      	lsls	r7, r7, #1
 800183e:	fbb0 f7f7 	udiv	r7, r0, r7
 8001842:	f7ff fcfd 	bl	8001240 <HAL_RCC_GetPCLK1Freq>
 8001846:	4360      	muls	r0, r4
 8001848:	f8d9 5004 	ldr.w	r5, [r9, #4]
 800184c:	fbb7 f7f8 	udiv	r7, r7, r8
 8001850:	006d      	lsls	r5, r5, #1
 8001852:	fbb0 f5f5 	udiv	r5, r0, r5
 8001856:	f7ff fcf3 	bl	8001240 <HAL_RCC_GetPCLK1Freq>
 800185a:	4360      	muls	r0, r4
 800185c:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8001860:	013f      	lsls	r7, r7, #4
 8001862:	005b      	lsls	r3, r3, #1
 8001864:	fbb0 f0f3 	udiv	r0, r0, r3
 8001868:	fbb0 f0f8 	udiv	r0, r0, r8
 800186c:	fb08 5510 	mls	r5, r8, r0, r5
 8001870:	f7ff fce6 	bl	8001240 <HAL_RCC_GetPCLK1Freq>
 8001874:	00ed      	lsls	r5, r5, #3
 8001876:	3532      	adds	r5, #50	; 0x32
 8001878:	fbb5 f5f8 	udiv	r5, r5, r8
 800187c:	4360      	muls	r0, r4
 800187e:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8001882:	006d      	lsls	r5, r5, #1
 8001884:	0049      	lsls	r1, r1, #1
 8001886:	f405 75f8 	and.w	r5, r5, #496	; 0x1f0
 800188a:	fbb0 faf1 	udiv	sl, r0, r1
 800188e:	f7ff fcd7 	bl	8001240 <HAL_RCC_GetPCLK1Freq>
 8001892:	4344      	muls	r4, r0
 8001894:	f8d9 0004 	ldr.w	r0, [r9, #4]
 8001898:	0040      	lsls	r0, r0, #1
 800189a:	fbb4 f0f0 	udiv	r0, r4, r0
 800189e:	fbb0 f0f8 	udiv	r0, r0, r8
 80018a2:	fb08 a210 	mls	r2, r8, r0, sl
 80018a6:	00d2      	lsls	r2, r2, #3
 80018a8:	3232      	adds	r2, #50	; 0x32
 80018aa:	fbb2 f3f8 	udiv	r3, r2, r8
 80018ae:	f003 0307 	and.w	r3, r3, #7
 80018b2:	443b      	add	r3, r7
 80018b4:	441d      	add	r5, r3
 80018b6:	60b5      	str	r5, [r6, #8]
 80018b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
  }
  else
  {
    /*------- UART-associated USART registers setting : BRR Configuration ------*/
    if((huart->Instance == USART1))
 80018bc:	429e      	cmp	r6, r3
 80018be:	f04f 0419 	mov.w	r4, #25
 80018c2:	d131      	bne.n	8001928 <UART_SetConfig+0x1bc>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 80018c4:	f7ff fcd4 	bl	8001270 <HAL_RCC_GetPCLK2Freq>
 80018c8:	4360      	muls	r0, r4
 80018ca:	f8d9 7004 	ldr.w	r7, [r9, #4]
 80018ce:	f04f 0864 	mov.w	r8, #100	; 0x64
 80018d2:	00bf      	lsls	r7, r7, #2
 80018d4:	fbb0 f7f7 	udiv	r7, r0, r7
 80018d8:	f7ff fcca 	bl	8001270 <HAL_RCC_GetPCLK2Freq>
 80018dc:	4360      	muls	r0, r4
 80018de:	f8d9 5004 	ldr.w	r5, [r9, #4]
 80018e2:	fbb7 f7f8 	udiv	r7, r7, r8
 80018e6:	00ad      	lsls	r5, r5, #2
 80018e8:	fbb0 f5f5 	udiv	r5, r0, r5
 80018ec:	f7ff fcc0 	bl	8001270 <HAL_RCC_GetPCLK2Freq>
 80018f0:	4360      	muls	r0, r4
 80018f2:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80018f6:	013f      	lsls	r7, r7, #4
 80018f8:	009b      	lsls	r3, r3, #2
 80018fa:	fbb0 f0f3 	udiv	r0, r0, r3
 80018fe:	fbb0 f0f8 	udiv	r0, r0, r8
 8001902:	fb08 5510 	mls	r5, r8, r0, r5
 8001906:	f7ff fcb3 	bl	8001270 <HAL_RCC_GetPCLK2Freq>
 800190a:	012d      	lsls	r5, r5, #4
 800190c:	3532      	adds	r5, #50	; 0x32
 800190e:	fbb5 f5f8 	udiv	r5, r5, r8
 8001912:	4360      	muls	r0, r4
 8001914:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8001918:	f005 05f0 	and.w	r5, r5, #240	; 0xf0
 800191c:	0089      	lsls	r1, r1, #2
 800191e:	fbb0 faf1 	udiv	sl, r0, r1
 8001922:	f7ff fca5 	bl	8001270 <HAL_RCC_GetPCLK2Freq>
 8001926:	e030      	b.n	800198a <UART_SetConfig+0x21e>
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8001928:	f7ff fc8a 	bl	8001240 <HAL_RCC_GetPCLK1Freq>
 800192c:	4360      	muls	r0, r4
 800192e:	f8d9 7004 	ldr.w	r7, [r9, #4]
 8001932:	f04f 0864 	mov.w	r8, #100	; 0x64
 8001936:	00bf      	lsls	r7, r7, #2
 8001938:	fbb0 f7f7 	udiv	r7, r0, r7
 800193c:	f7ff fc80 	bl	8001240 <HAL_RCC_GetPCLK1Freq>
 8001940:	4360      	muls	r0, r4
 8001942:	f8d9 5004 	ldr.w	r5, [r9, #4]
 8001946:	fbb7 f7f8 	udiv	r7, r7, r8
 800194a:	00ad      	lsls	r5, r5, #2
 800194c:	fbb0 f5f5 	udiv	r5, r0, r5
 8001950:	f7ff fc76 	bl	8001240 <HAL_RCC_GetPCLK1Freq>
 8001954:	4360      	muls	r0, r4
 8001956:	f8d9 3004 	ldr.w	r3, [r9, #4]
 800195a:	013f      	lsls	r7, r7, #4
 800195c:	009b      	lsls	r3, r3, #2
 800195e:	fbb0 f0f3 	udiv	r0, r0, r3
 8001962:	fbb0 f0f8 	udiv	r0, r0, r8
 8001966:	fb08 5510 	mls	r5, r8, r0, r5
 800196a:	f7ff fc69 	bl	8001240 <HAL_RCC_GetPCLK1Freq>
 800196e:	012d      	lsls	r5, r5, #4
 8001970:	3532      	adds	r5, #50	; 0x32
 8001972:	fbb5 f5f8 	udiv	r5, r5, r8
 8001976:	4360      	muls	r0, r4
 8001978:	f8d9 1004 	ldr.w	r1, [r9, #4]
 800197c:	f005 05f0 	and.w	r5, r5, #240	; 0xf0
 8001980:	0089      	lsls	r1, r1, #2
 8001982:	fbb0 faf1 	udiv	sl, r0, r1
 8001986:	f7ff fc5b 	bl	8001240 <HAL_RCC_GetPCLK1Freq>
 800198a:	4344      	muls	r4, r0
 800198c:	f8d9 0004 	ldr.w	r0, [r9, #4]
 8001990:	0080      	lsls	r0, r0, #2
 8001992:	fbb4 f0f0 	udiv	r0, r4, r0
 8001996:	fbb0 f0f8 	udiv	r0, r0, r8
 800199a:	fb08 a210 	mls	r2, r8, r0, sl
 800199e:	0112      	lsls	r2, r2, #4
 80019a0:	3232      	adds	r2, #50	; 0x32
 80019a2:	fbb2 f3f8 	udiv	r3, r2, r8
 80019a6:	f003 030f 	and.w	r3, r3, #15
 80019aa:	442b      	add	r3, r5
 80019ac:	441f      	add	r7, r3
 80019ae:	60b7      	str	r7, [r6, #8]
 80019b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80019b4:	40013800 	.word	0x40013800

080019b8 <UART_WaitOnFlagUntilTimeout.constprop.1>:
  * @param  Flag: specifies the UART flag to check.
  * @param  Status: The new Flag status (SET or RESET).
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
 80019b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80019ba:	4604      	mov	r4, r0
 80019bc:	460e      	mov	r6, r1
 80019be:	4615      	mov	r5, r2
{
  uint32_t tickstart = 0;

  /* Get tick */ 
  tickstart = HAL_GetTick();
 80019c0:	f7fe fe42 	bl	8000648 <HAL_GetTick>
 80019c4:	4607      	mov	r7, r0

  /* Wait until flag is set */
  if(Status == RESET)
  {
    while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
 80019c6:	6822      	ldr	r2, [r4, #0]
 80019c8:	6813      	ldr	r3, [r2, #0]
 80019ca:	ea36 0303 	bics.w	r3, r6, r3
 80019ce:	d021      	beq.n	8001a14 <UART_WaitOnFlagUntilTimeout.constprop.1+0x5c>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 80019d0:	1c6b      	adds	r3, r5, #1
 80019d2:	d0f9      	beq.n	80019c8 <UART_WaitOnFlagUntilTimeout.constprop.1+0x10>
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 80019d4:	b9c5      	cbnz	r5, 8001a08 <UART_WaitOnFlagUntilTimeout.constprop.1+0x50>
        {
          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
          __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 80019d6:	6823      	ldr	r3, [r4, #0]
          huart->State= HAL_UART_STATE_READY;

          /* Process Unlocked */
          __HAL_UNLOCK(huart);

          return HAL_TIMEOUT;
 80019d8:	2003      	movs	r0, #3
      if(Timeout != HAL_MAX_DELAY)
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
        {
          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
          __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 80019da:	68da      	ldr	r2, [r3, #12]
 80019dc:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80019e0:	60da      	str	r2, [r3, #12]
          __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 80019e2:	68da      	ldr	r2, [r3, #12]
 80019e4:	f022 0220 	bic.w	r2, r2, #32
 80019e8:	60da      	str	r2, [r3, #12]
          __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 80019ea:	68da      	ldr	r2, [r3, #12]
 80019ec:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80019f0:	60da      	str	r2, [r3, #12]
          __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 80019f2:	695a      	ldr	r2, [r3, #20]
 80019f4:	f022 0201 	bic.w	r2, r2, #1
 80019f8:	615a      	str	r2, [r3, #20]

          huart->State= HAL_UART_STATE_READY;
 80019fa:	2301      	movs	r3, #1
 80019fc:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8001a00:	2300      	movs	r3, #0
 8001a02:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
 8001a06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
        if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8001a08:	f7fe fe1e 	bl	8000648 <HAL_GetTick>
 8001a0c:	1bc0      	subs	r0, r0, r7
 8001a0e:	4285      	cmp	r5, r0
 8001a10:	d2d9      	bcs.n	80019c6 <UART_WaitOnFlagUntilTimeout.constprop.1+0xe>
 8001a12:	e7e0      	b.n	80019d6 <UART_WaitOnFlagUntilTimeout.constprop.1+0x1e>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 8001a14:	2000      	movs	r0, #0
}
 8001a16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001a18 <HAL_MultiProcessor_Init>:
  *            @arg UART_WAKEUPMETHOD_IDLELINE: Wakeup by an idle line detection
  *            @arg UART_WAKEUPMETHOD_ADDRESSMARK: Wakeup by an address mark
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
{
 8001a18:	b570      	push	{r4, r5, r6, lr}
 8001a1a:	460e      	mov	r6, r1
 8001a1c:	4615      	mov	r5, r2
  /* Check the UART handle allocation */
  if(huart == NULL)
 8001a1e:	4604      	mov	r4, r0
 8001a20:	2800      	cmp	r0, #0
 8001a22:	d030      	beq.n	8001a86 <HAL_MultiProcessor_Init+0x6e>
  assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
  assert_param(IS_UART_ADDRESS(Address));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));

  if(huart->State == HAL_UART_STATE_RESET)
 8001a24:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8001a28:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001a2c:	b91b      	cbnz	r3, 8001a36 <HAL_MultiProcessor_Init+0x1e>
  {   
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8001a2e:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38

    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
 8001a32:	f7fe fd8f 	bl	8000554 <HAL_UART_MspInit>
  }

  huart->State = HAL_UART_STATE_BUSY;

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8001a36:	6822      	ldr	r2, [r4, #0]

    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
  }

  huart->State = HAL_UART_STATE_BUSY;
 8001a38:	2302      	movs	r3, #2
 8001a3a:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8001a3e:	68d3      	ldr	r3, [r2, #12]
  
  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 8001a40:	4620      	mov	r0, r4
  }

  huart->State = HAL_UART_STATE_BUSY;

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8001a42:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001a46:	60d3      	str	r3, [r2, #12]
  
  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 8001a48:	f7ff fe90 	bl	800176c <UART_SetConfig>
  
  /* In Multi-Processor mode, the following bits must be kept cleared: 
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001a4c:	6823      	ldr	r3, [r4, #0]
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001a4e:	2000      	movs	r0, #0
  UART_SetConfig(huart);
  
  /* In Multi-Processor mode, the following bits must be kept cleared: 
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001a50:	691a      	ldr	r2, [r3, #16]
 8001a52:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8001a56:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8001a58:	695a      	ldr	r2, [r3, #20]
 8001a5a:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8001a5e:	615a      	str	r2, [r3, #20]
  
  /* Set the USART address node */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, Address);
 8001a60:	691a      	ldr	r2, [r3, #16]
 8001a62:	f022 020f 	bic.w	r2, r2, #15
 8001a66:	4316      	orrs	r6, r2
 8001a68:	611e      	str	r6, [r3, #16]
  
  /* Set the wake up method by setting the WAKE bit in the CR1 register */
  MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
 8001a6a:	68da      	ldr	r2, [r3, #12]
 8001a6c:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001a70:	4315      	orrs	r5, r2
 8001a72:	60dd      	str	r5, [r3, #12]
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8001a74:	68da      	ldr	r2, [r3, #12]
 8001a76:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001a7a:	60da      	str	r2, [r3, #12]
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->State= HAL_UART_STATE_READY;
 8001a7c:	2301      	movs	r3, #1
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001a7e:	63e0      	str	r0, [r4, #60]	; 0x3c
  huart->State= HAL_UART_STATE_READY;
 8001a80:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  
  return HAL_OK;
 8001a84:	bd70      	pop	{r4, r5, r6, pc}
HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
{
  /* Check the UART handle allocation */
  if(huart == NULL)
  {
    return HAL_ERROR;
 8001a86:	2001      	movs	r0, #1
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->State= HAL_UART_STATE_READY;
  
  return HAL_OK;
}
 8001a88:	bd70      	pop	{r4, r5, r6, pc}

08001a8a <HAL_UART_Transmit>:
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8001a8a:	b570      	push	{r4, r5, r6, lr}
 8001a8c:	460d      	mov	r5, r1
  uint16_t* tmp;
  uint32_t tmp_state = 0;
  
  tmp_state = huart->State;
 8001a8e:	f890 1039 	ldrb.w	r1, [r0, #57]	; 0x39
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8001a92:	4604      	mov	r4, r0
  uint16_t* tmp;
  uint32_t tmp_state = 0;
  
  tmp_state = huart->State;
 8001a94:	b2c9      	uxtb	r1, r1
  if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
 8001a96:	2901      	cmp	r1, #1
  * @param  Size: Amount of data to be sent
  * @param  Timeout: Timeout duration  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8001a98:	461e      	mov	r6, r3
  uint16_t* tmp;
  uint32_t tmp_state = 0;
  
  tmp_state = huart->State;
  if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
 8001a9a:	d001      	beq.n	8001aa0 <HAL_UART_Transmit+0x16>
 8001a9c:	2922      	cmp	r1, #34	; 0x22
 8001a9e:	d14e      	bne.n	8001b3e <HAL_UART_Transmit+0xb4>
  {
    if((pData == NULL) || (Size == 0))
 8001aa0:	2d00      	cmp	r5, #0
 8001aa2:	d04a      	beq.n	8001b3a <HAL_UART_Transmit+0xb0>
 8001aa4:	2a00      	cmp	r2, #0
 8001aa6:	d048      	beq.n	8001b3a <HAL_UART_Transmit+0xb0>
    {
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 8001aa8:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8001aac:	2b01      	cmp	r3, #1
 8001aae:	d046      	beq.n	8001b3e <HAL_UART_Transmit+0xb4>
 8001ab0:	2301      	movs	r3, #1
 8001ab2:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001ab6:	2300      	movs	r3, #0
 8001ab8:	63e3      	str	r3, [r4, #60]	; 0x3c
    /* Check if a non-blocking receive process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_RX) 
 8001aba:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
    else
    {
      huart->State = HAL_UART_STATE_BUSY_TX;
    }

    huart->TxXferSize = Size;
 8001abe:	84a2      	strh	r2, [r4, #36]	; 0x24
    /* Process Locked */
    __HAL_LOCK(huart);

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    /* Check if a non-blocking receive process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_RX) 
 8001ac0:	2b22      	cmp	r3, #34	; 0x22
    {
      huart->State = HAL_UART_STATE_BUSY_TX_RX;
 8001ac2:	bf0c      	ite	eq
 8001ac4:	2332      	moveq	r3, #50	; 0x32
    }
    else
    {
      huart->State = HAL_UART_STATE_BUSY_TX;
 8001ac6:	2312      	movne	r3, #18
 8001ac8:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
    }

    huart->TxXferSize = Size;
    huart->TxXferCount = Size;
 8001acc:	84e2      	strh	r2, [r4, #38]	; 0x26
    while(huart->TxXferCount > 0)
 8001ace:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8001ad0:	b302      	cbz	r2, 8001b14 <HAL_UART_Transmit+0x8a>
    {
      huart->TxXferCount--;
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8001ad2:	68a3      	ldr	r3, [r4, #8]

    huart->TxXferSize = Size;
    huart->TxXferCount = Size;
    while(huart->TxXferCount > 0)
    {
      huart->TxXferCount--;
 8001ad4:	3a01      	subs	r2, #1
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8001ad6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000

    huart->TxXferSize = Size;
    huart->TxXferCount = Size;
    while(huart->TxXferCount > 0)
    {
      huart->TxXferCount--;
 8001ada:	84e2      	strh	r2, [r4, #38]	; 0x26
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
      {
        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8001adc:	f04f 0180 	mov.w	r1, #128	; 0x80
 8001ae0:	4632      	mov	r2, r6
 8001ae2:	4620      	mov	r0, r4
    huart->TxXferSize = Size;
    huart->TxXferCount = Size;
    while(huart->TxXferCount > 0)
    {
      huart->TxXferCount--;
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8001ae4:	d10d      	bne.n	8001b02 <HAL_UART_Transmit+0x78>
      {
        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8001ae6:	f7ff ff67 	bl	80019b8 <UART_WaitOnFlagUntilTimeout.constprop.1>
 8001aea:	b108      	cbz	r0, 8001af0 <HAL_UART_Transmit+0x66>
        {
          return HAL_TIMEOUT;
 8001aec:	2003      	movs	r0, #3
 8001aee:	bd70      	pop	{r4, r5, r6, pc}
        }
        tmp = (uint16_t*) pData;
        huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
 8001af0:	882b      	ldrh	r3, [r5, #0]
 8001af2:	6822      	ldr	r2, [r4, #0]
 8001af4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001af8:	6053      	str	r3, [r2, #4]
        if(huart->Init.Parity == UART_PARITY_NONE)
 8001afa:	6923      	ldr	r3, [r4, #16]
 8001afc:	b943      	cbnz	r3, 8001b10 <HAL_UART_Transmit+0x86>
        {
          pData +=2;
 8001afe:	3502      	adds	r5, #2
 8001b00:	e7e5      	b.n	8001ace <HAL_UART_Transmit+0x44>
          pData +=1;
        }
      } 
      else
      {
        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
 8001b02:	f7ff ff59 	bl	80019b8 <UART_WaitOnFlagUntilTimeout.constprop.1>
 8001b06:	2800      	cmp	r0, #0
 8001b08:	d1f0      	bne.n	8001aec <HAL_UART_Transmit+0x62>
        {
          return HAL_TIMEOUT;
        }
        huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
 8001b0a:	6823      	ldr	r3, [r4, #0]
 8001b0c:	782a      	ldrb	r2, [r5, #0]
 8001b0e:	605a      	str	r2, [r3, #4]
 8001b10:	3501      	adds	r5, #1
 8001b12:	e7dc      	b.n	8001ace <HAL_UART_Transmit+0x44>
      }
    }

    if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, Timeout) != HAL_OK)
 8001b14:	4632      	mov	r2, r6
 8001b16:	2140      	movs	r1, #64	; 0x40
 8001b18:	4620      	mov	r0, r4
 8001b1a:	f7ff ff4d 	bl	80019b8 <UART_WaitOnFlagUntilTimeout.constprop.1>
 8001b1e:	2800      	cmp	r0, #0
 8001b20:	d1e4      	bne.n	8001aec <HAL_UART_Transmit+0x62>
    { 
      return HAL_TIMEOUT;
    }

    /* Check if a non-blocking receive process is ongoing or not */
    if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
 8001b22:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 8001b26:	2b32      	cmp	r3, #50	; 0x32
    {
      huart->State = HAL_UART_STATE_BUSY_RX;
 8001b28:	bf0c      	ite	eq
 8001b2a:	2322      	moveq	r3, #34	; 0x22
    }
    else
    {
      huart->State = HAL_UART_STATE_READY;
 8001b2c:	2301      	movne	r3, #1
 8001b2e:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
    }

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8001b32:	2300      	movs	r3, #0
 8001b34:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38

    return HAL_OK;
 8001b38:	bd70      	pop	{r4, r5, r6, pc}
  tmp_state = huart->State;
  if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
  {
    if((pData == NULL) || (Size == 0))
    {
      return  HAL_ERROR;
 8001b3a:	2001      	movs	r0, #1
 8001b3c:	bd70      	pop	{r4, r5, r6, pc}

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8001b3e:	2002      	movs	r0, #2
  }
}
 8001b40:	bd70      	pop	{r4, r5, r6, pc}

08001b42 <HAL_UART_TxCpltCallback>:
 8001b42:	4770      	bx	lr

08001b44 <HAL_UART_RxCpltCallback>:
 8001b44:	4770      	bx	lr

08001b46 <HAL_UART_ErrorCallback>:
  * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
 __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8001b46:	4770      	bx	lr

08001b48 <HAL_UART_IRQHandler>:
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
  uint32_t tmp_flag = 0, tmp_it_source = 0;

  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
 8001b48:	6802      	ldr	r2, [r0, #0]
  * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8001b4a:	b513      	push	{r0, r1, r4, lr}
  uint32_t tmp_flag = 0, tmp_it_source = 0;

  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
 8001b4c:	6811      	ldr	r1, [r2, #0]
  * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8001b4e:	4604      	mov	r4, r0
  uint32_t tmp_flag = 0, tmp_it_source = 0;

  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE);  
  /* UART parity error interrupt occurred ------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001b50:	07c9      	lsls	r1, r1, #31
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
  uint32_t tmp_flag = 0, tmp_it_source = 0;

  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE);  
 8001b52:	68d3      	ldr	r3, [r2, #12]
  /* UART parity error interrupt occurred ------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001b54:	d505      	bpl.n	8001b62 <HAL_UART_IRQHandler+0x1a>
 8001b56:	05db      	lsls	r3, r3, #23
  { 
    huart->ErrorCode |= HAL_UART_ERROR_PE;
 8001b58:	bf42      	ittt	mi
 8001b5a:	6bc3      	ldrmi	r3, [r0, #60]	; 0x3c
 8001b5c:	f043 0301 	orrmi.w	r3, r3, #1
 8001b60:	63c3      	strmi	r3, [r0, #60]	; 0x3c
  }
  
  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_FE);
 8001b62:	6811      	ldr	r1, [r2, #0]
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
 8001b64:	6953      	ldr	r3, [r2, #20]
  /* UART frame error interrupt occurred -------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001b66:	0788      	lsls	r0, r1, #30
  { 
    huart->ErrorCode |= HAL_UART_ERROR_PE;
  }
  
  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_FE);
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
 8001b68:	f003 0301 	and.w	r3, r3, #1
  /* UART frame error interrupt occurred -------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001b6c:	d504      	bpl.n	8001b78 <HAL_UART_IRQHandler+0x30>
 8001b6e:	b11b      	cbz	r3, 8001b78 <HAL_UART_IRQHandler+0x30>
  {
    huart->ErrorCode |= HAL_UART_ERROR_FE;
 8001b70:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001b72:	f041 0104 	orr.w	r1, r1, #4
 8001b76:	63e1      	str	r1, [r4, #60]	; 0x3c
  }
  
  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_NE);
 8001b78:	6811      	ldr	r1, [r2, #0]
  /* UART noise error interrupt occurred -------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001b7a:	0749      	lsls	r1, r1, #29
 8001b7c:	d504      	bpl.n	8001b88 <HAL_UART_IRQHandler+0x40>
 8001b7e:	b11b      	cbz	r3, 8001b88 <HAL_UART_IRQHandler+0x40>
  {
    huart->ErrorCode |= HAL_UART_ERROR_NE;
 8001b80:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001b82:	f041 0102 	orr.w	r1, r1, #2
 8001b86:	63e1      	str	r1, [r4, #60]	; 0x3c
  }
  
  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_ORE);
 8001b88:	6811      	ldr	r1, [r2, #0]
  /* UART Over-Run interrupt occurred ----------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001b8a:	0708      	lsls	r0, r1, #28
 8001b8c:	d504      	bpl.n	8001b98 <HAL_UART_IRQHandler+0x50>
 8001b8e:	b11b      	cbz	r3, 8001b98 <HAL_UART_IRQHandler+0x50>
  {
    huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8001b90:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001b92:	f043 0308 	orr.w	r3, r3, #8
 8001b96:	63e3      	str	r3, [r4, #60]	; 0x3c
  }
  
  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE);
 8001b98:	6811      	ldr	r1, [r2, #0]
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE);
 8001b9a:	68d3      	ldr	r3, [r2, #12]
  /* UART in mode Receiver ---------------------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001b9c:	0689      	lsls	r1, r1, #26
 8001b9e:	d542      	bpl.n	8001c26 <HAL_UART_IRQHandler+0xde>
 8001ba0:	0698      	lsls	r0, r3, #26
 8001ba2:	d540      	bpl.n	8001c26 <HAL_UART_IRQHandler+0xde>
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  uint32_t tmp_state = 0;
  
  tmp_state = huart->State; 
 8001ba4:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
  if((tmp_state == HAL_UART_STATE_BUSY_RX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
 8001ba8:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 8001bac:	2b22      	cmp	r3, #34	; 0x22
 8001bae:	d13a      	bne.n	8001c26 <HAL_UART_IRQHandler+0xde>
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8001bb0:	68a3      	ldr	r3, [r4, #8]
 8001bb2:	6921      	ldr	r1, [r4, #16]
 8001bb4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001bb8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001bba:	d10b      	bne.n	8001bd4 <HAL_UART_IRQHandler+0x8c>
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
      if(huart->Init.Parity == UART_PARITY_NONE)
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8001bbc:	6852      	ldr	r2, [r2, #4]
  if((tmp_state == HAL_UART_STATE_BUSY_RX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
      if(huart->Init.Parity == UART_PARITY_NONE)
 8001bbe:	b921      	cbnz	r1, 8001bca <HAL_UART_IRQHandler+0x82>
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8001bc0:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8001bc4:	f823 2b02 	strh.w	r2, [r3], #2
 8001bc8:	e002      	b.n	8001bd0 <HAL_UART_IRQHandler+0x88>
        huart->pRxBuffPtr += 2;
      }
      else
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
 8001bca:	b2d2      	uxtb	r2, r2
 8001bcc:	f823 2b01 	strh.w	r2, [r3], #1
        huart->pRxBuffPtr += 1;
 8001bd0:	62a3      	str	r3, [r4, #40]	; 0x28
 8001bd2:	e00a      	b.n	8001bea <HAL_UART_IRQHandler+0xa2>
      }
    }
    else
    {
      if(huart->Init.Parity == UART_PARITY_NONE)
 8001bd4:	b919      	cbnz	r1, 8001bde <HAL_UART_IRQHandler+0x96>
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8001bd6:	1c59      	adds	r1, r3, #1
 8001bd8:	62a1      	str	r1, [r4, #40]	; 0x28
 8001bda:	6852      	ldr	r2, [r2, #4]
 8001bdc:	e004      	b.n	8001be8 <HAL_UART_IRQHandler+0xa0>
      }
      else
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8001bde:	6852      	ldr	r2, [r2, #4]
 8001be0:	1c59      	adds	r1, r3, #1
 8001be2:	62a1      	str	r1, [r4, #40]	; 0x28
 8001be4:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8001be8:	701a      	strb	r2, [r3, #0]
      }
    }

    if(--huart->RxXferCount == 0)
 8001bea:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 8001bec:	3b01      	subs	r3, #1
 8001bee:	b29b      	uxth	r3, r3
 8001bf0:	85e3      	strh	r3, [r4, #46]	; 0x2e
 8001bf2:	b9c3      	cbnz	r3, 8001c26 <HAL_UART_IRQHandler+0xde>
    {
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 8001bf4:	6823      	ldr	r3, [r4, #0]
        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
        __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);

        huart->State = HAL_UART_STATE_READY;
      }
      HAL_UART_RxCpltCallback(huart);
 8001bf6:	4620      	mov	r0, r4
      }
    }

    if(--huart->RxXferCount == 0)
    {
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 8001bf8:	68da      	ldr	r2, [r3, #12]
 8001bfa:	f022 0220 	bic.w	r2, r2, #32
 8001bfe:	60da      	str	r2, [r3, #12]

      /* Check if a transmit process is ongoing or not */
      if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
 8001c00:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 8001c04:	2a32      	cmp	r2, #50	; 0x32
        huart->State = HAL_UART_STATE_BUSY_TX;
      }
      else
      {
        /* Disable the UART Parity Error Interrupt */
        __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 8001c06:	bf17      	itett	ne
 8001c08:	68da      	ldrne	r2, [r3, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);

      /* Check if a transmit process is ongoing or not */
      if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
      {
        huart->State = HAL_UART_STATE_BUSY_TX;
 8001c0a:	2312      	moveq	r3, #18
      }
      else
      {
        /* Disable the UART Parity Error Interrupt */
        __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 8001c0c:	f422 7280 	bicne.w	r2, r2, #256	; 0x100
 8001c10:	60da      	strne	r2, [r3, #12]

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
        __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 8001c12:	bf1f      	itttt	ne
 8001c14:	695a      	ldrne	r2, [r3, #20]
 8001c16:	f022 0201 	bicne.w	r2, r2, #1
 8001c1a:	615a      	strne	r2, [r3, #20]

        huart->State = HAL_UART_STATE_READY;
 8001c1c:	2301      	movne	r3, #1
 8001c1e:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
      }
      HAL_UART_RxCpltCallback(huart);
 8001c22:	f7ff ff8f 	bl	8001b44 <HAL_UART_RxCpltCallback>
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
  { 
    UART_Receive_IT(huart);
  }
  
  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TXE);
 8001c26:	6823      	ldr	r3, [r4, #0]
 8001c28:	6819      	ldr	r1, [r3, #0]
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE);
 8001c2a:	68da      	ldr	r2, [r3, #12]
  /* UART in mode Transmitter ------------------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001c2c:	0609      	lsls	r1, r1, #24
 8001c2e:	d528      	bpl.n	8001c82 <HAL_UART_IRQHandler+0x13a>
 8001c30:	0610      	lsls	r0, r2, #24
 8001c32:	d526      	bpl.n	8001c82 <HAL_UART_IRQHandler+0x13a>
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  uint32_t tmp_state = 0;
  
  tmp_state = huart->State;
 8001c34:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
  if((tmp_state == HAL_UART_STATE_BUSY_TX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
 8001c38:	f002 02df 	and.w	r2, r2, #223	; 0xdf
 8001c3c:	2a12      	cmp	r2, #18
 8001c3e:	d120      	bne.n	8001c82 <HAL_UART_IRQHandler+0x13a>
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8001c40:	68a2      	ldr	r2, [r4, #8]
 8001c42:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8001c46:	6a22      	ldr	r2, [r4, #32]
 8001c48:	d10a      	bne.n	8001c60 <HAL_UART_IRQHandler+0x118>
    {
      tmp = (uint16_t*) huart->pTxBuffPtr;
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 8001c4a:	8811      	ldrh	r1, [r2, #0]
 8001c4c:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8001c50:	6059      	str	r1, [r3, #4]
      if(huart->Init.Parity == UART_PARITY_NONE)
 8001c52:	6921      	ldr	r1, [r4, #16]
 8001c54:	b909      	cbnz	r1, 8001c5a <HAL_UART_IRQHandler+0x112>
      {
        huart->pTxBuffPtr += 2;
 8001c56:	3202      	adds	r2, #2
 8001c58:	e000      	b.n	8001c5c <HAL_UART_IRQHandler+0x114>
      }
      else
      {
        huart->pTxBuffPtr += 1;
 8001c5a:	3201      	adds	r2, #1
 8001c5c:	6222      	str	r2, [r4, #32]
 8001c5e:	e003      	b.n	8001c68 <HAL_UART_IRQHandler+0x120>
      }
    } 
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 8001c60:	1c51      	adds	r1, r2, #1
 8001c62:	6221      	str	r1, [r4, #32]
 8001c64:	7812      	ldrb	r2, [r2, #0]
 8001c66:	605a      	str	r2, [r3, #4]
    }

    if(--huart->TxXferCount == 0)
 8001c68:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8001c6a:	3a01      	subs	r2, #1
 8001c6c:	b292      	uxth	r2, r2
 8001c6e:	84e2      	strh	r2, [r4, #38]	; 0x26
 8001c70:	b93a      	cbnz	r2, 8001c82 <HAL_UART_IRQHandler+0x13a>
    {
      /* Disable the UART Transmit Complete Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 8001c72:	68da      	ldr	r2, [r3, #12]
 8001c74:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001c78:	60da      	str	r2, [r3, #12]

      /* Enable the UART Transmit Complete Interrupt */    
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 8001c7a:	68da      	ldr	r2, [r3, #12]
 8001c7c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001c80:	60da      	str	r2, [r3, #12]
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
  {
    UART_Transmit_IT(huart);
  }

  tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TC);
 8001c82:	6819      	ldr	r1, [r3, #0]
  tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TC);
 8001c84:	68da      	ldr	r2, [r3, #12]
  /* UART in mode Transmitter end --------------------------------------------*/
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
 8001c86:	0649      	lsls	r1, r1, #25
 8001c88:	d510      	bpl.n	8001cac <HAL_UART_IRQHandler+0x164>
 8001c8a:	0652      	lsls	r2, r2, #25
 8001c8c:	d50e      	bpl.n	8001cac <HAL_UART_IRQHandler+0x164>
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */    
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8001c8e:	68da      	ldr	r2, [r3, #12]
  else
  {
    huart->State = HAL_UART_STATE_READY;
  }
  
  HAL_UART_TxCpltCallback(huart);
 8001c90:	4620      	mov	r0, r4
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */    
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8001c92:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001c96:	60da      	str	r2, [r3, #12]
  
  /* Check if a receive process is ongoing or not */
  if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
 8001c98:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 8001c9c:	2b32      	cmp	r3, #50	; 0x32
  {
    huart->State = HAL_UART_STATE_BUSY_RX;
 8001c9e:	bf0c      	ite	eq
 8001ca0:	2322      	moveq	r3, #34	; 0x22
  }
  else
  {
    huart->State = HAL_UART_STATE_READY;
 8001ca2:	2301      	movne	r3, #1
 8001ca4:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  }
  
  HAL_UART_TxCpltCallback(huart);
 8001ca8:	f7ff ff4b 	bl	8001b42 <HAL_UART_TxCpltCallback>
  if((tmp_flag != RESET) && (tmp_it_source != RESET))
  {
    UART_EndTransmit_IT(huart);
  }  

  if(huart->ErrorCode != HAL_UART_ERROR_NONE)
 8001cac:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001cae:	b15b      	cbz	r3, 8001cc8 <HAL_UART_IRQHandler+0x180>
  {
    /* Clear all the error flag at once */
    __HAL_UART_CLEAR_PEFLAG(huart);
 8001cb0:	6823      	ldr	r3, [r4, #0]
    
    /* Set the UART state ready to be able to start again the process */
    huart->State = HAL_UART_STATE_READY;
    
    HAL_UART_ErrorCallback(huart);
 8001cb2:	4620      	mov	r0, r4
  }  

  if(huart->ErrorCode != HAL_UART_ERROR_NONE)
  {
    /* Clear all the error flag at once */
    __HAL_UART_CLEAR_PEFLAG(huart);
 8001cb4:	681a      	ldr	r2, [r3, #0]
 8001cb6:	9201      	str	r2, [sp, #4]
 8001cb8:	685b      	ldr	r3, [r3, #4]
 8001cba:	9301      	str	r3, [sp, #4]
 8001cbc:	9b01      	ldr	r3, [sp, #4]
    
    /* Set the UART state ready to be able to start again the process */
    huart->State = HAL_UART_STATE_READY;
 8001cbe:	2301      	movs	r3, #1
 8001cc0:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
    
    HAL_UART_ErrorCallback(huart);
 8001cc4:	f7ff ff3f 	bl	8001b46 <HAL_UART_ErrorCallback>
  }  
}
 8001cc8:	b002      	add	sp, #8
 8001cca:	bd10      	pop	{r4, pc}

08001ccc <rfm7x_register_write>:
  }
  return value;
}*/

void rfm7x_register_write( unsigned char reg, unsigned char value )
{
 8001ccc:	b538      	push	{r3, r4, r5, lr}
 8001cce:	4604      	mov	r4, r0
 8001cd0:	460d      	mov	r5, r1
   if( reg < RFM7x_CMD_WRITE_REG ){
 8001cd2:	281f      	cmp	r0, #31
      reg |= RFM7x_CMD_WRITE_REG;
 8001cd4:	bf98      	it	ls
 8001cd6:	f040 0420 	orrls.w	r4, r0, #32
   }
   RFM7x_CSN( 0 );                // CSN low, init SPI transaction
 8001cda:	2000      	movs	r0, #0
 8001cdc:	f000 f9be 	bl	800205c <RFM7x_CSN>
   (void)rfm7x_SPI_RW( reg );    // select register
 8001ce0:	4620      	mov	r0, r4
 8001ce2:	f000 f9c7 	bl	8002074 <rfm7x_SPI_RW>
   (void)rfm7x_SPI_RW( value );  // ..and write value to it..
 8001ce6:	4628      	mov	r0, r5
 8001ce8:	f000 f9c4 	bl	8002074 <rfm7x_SPI_RW>
   RFM7x_CSN( 1 );                // CSN high again
}
 8001cec:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      reg |= RFM7x_CMD_WRITE_REG;
   }
   RFM7x_CSN( 0 );                // CSN low, init SPI transaction
   (void)rfm7x_SPI_RW( reg );    // select register
   (void)rfm7x_SPI_RW( value );  // ..and write value to it..
   RFM7x_CSN( 1 );                // CSN high again
 8001cf0:	2001      	movs	r0, #1
 8001cf2:	f000 b9b3 	b.w	800205c <RFM7x_CSN>

08001cf6 <rfm7x_register_read>:
}

unsigned char rfm7x_register_read( unsigned char reg ){
 8001cf6:	b510      	push	{r4, lr}
 8001cf8:	4604      	mov	r4, r0
   unsigned char value;
   //if( reg < RFM7x_CMD_WRITE_REG ){
   //   reg |= RFM7x_CMD_READ_REG;
   //}
   RFM7x_CSN( 0 );               // CSN low, initialize SPI communication...
 8001cfa:	2000      	movs	r0, #0
 8001cfc:	f000 f9ae 	bl	800205c <RFM7x_CSN>
   (void)rfm7x_SPI_RW( reg );   // Select register to read from..
 8001d00:	4620      	mov	r0, r4
 8001d02:	f000 f9b7 	bl	8002074 <rfm7x_SPI_RW>
   value = rfm7x_SPI_RW( 0 );   // ..then read register value
 8001d06:	2000      	movs	r0, #0
 8001d08:	f000 f9b4 	bl	8002074 <rfm7x_SPI_RW>
 8001d0c:	4604      	mov	r4, r0
   RFM7x_CSN( 1 );               // CSN high, terminate SPI communication
 8001d0e:	2001      	movs	r0, #1
 8001d10:	f000 f9a4 	bl	800205c <RFM7x_CSN>
   return value;                 // return register value
}
 8001d14:	4620      	mov	r0, r4
 8001d16:	bd10      	pop	{r4, pc}

08001d18 <rfm7x_buffer_read>:

void rfm7x_buffer_read(  unsigned char reg,  unsigned char *pBuf, unsigned char length ){
 8001d18:	b570      	push	{r4, r5, r6, lr}
 8001d1a:	4606      	mov	r6, r0
   unsigned char i;
   //if( reg < RFM7x_CMD_WRITE_REG ){
//      reg |= RFM7x_CMD_READ_REG;
//   }
   RFM7x_CSN( 0 );                   // Set CSN 0
 8001d1c:	2000      	movs	r0, #0
   value = rfm7x_SPI_RW( 0 );   // ..then read register value
   RFM7x_CSN( 1 );               // CSN high, terminate SPI communication
   return value;                 // return register value
}

void rfm7x_buffer_read(  unsigned char reg,  unsigned char *pBuf, unsigned char length ){
 8001d1e:	460c      	mov	r4, r1
 8001d20:	4615      	mov	r5, r2
   unsigned char i;
   //if( reg < RFM7x_CMD_WRITE_REG ){
//      reg |= RFM7x_CMD_READ_REG;
//   }
   RFM7x_CSN( 0 );                   // Set CSN 0
 8001d22:	f000 f99b 	bl	800205c <RFM7x_CSN>
   (void)rfm7x_SPI_RW( reg );       // Select register to write
 8001d26:	4630      	mov	r0, r6
 8001d28:	f000 f9a4 	bl	8002074 <rfm7x_SPI_RW>
 8001d2c:	4425      	add	r5, r4
   for( i = 0; i < length; i++ ){    // read all bytes
 8001d2e:	42ac      	cmp	r4, r5
 8001d30:	d005      	beq.n	8001d3e <rfm7x_buffer_read+0x26>
      *pBuf++ = rfm7x_SPI_RW( 0 );  // read one byte from RFM7x
 8001d32:	2000      	movs	r0, #0
 8001d34:	f000 f99e 	bl	8002074 <rfm7x_SPI_RW>
 8001d38:	f804 0b01 	strb.w	r0, [r4], #1
 8001d3c:	e7f7      	b.n	8001d2e <rfm7x_buffer_read+0x16>
   }
   RFM7x_CSN( 1 );                   // Set CSN high again
 8001d3e:	2001      	movs	r0, #1
}
 8001d40:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   RFM7x_CSN( 0 );                   // Set CSN 0
   (void)rfm7x_SPI_RW( reg );       // Select register to write
   for( i = 0; i < length; i++ ){    // read all bytes
      *pBuf++ = rfm7x_SPI_RW( 0 );  // read one byte from RFM7x
   }
   RFM7x_CSN( 1 );                   // Set CSN high again
 8001d44:	f000 b98a 	b.w	800205c <RFM7x_CSN>

08001d48 <rfm7x_buffer_write>:
}

void rfm7x_buffer_write( unsigned char reg,  const unsigned char *pBuf,  unsigned char length  ){
 8001d48:	b570      	push	{r4, r5, r6, lr}
 8001d4a:	4605      	mov	r5, r0
   unsigned char i;
   if( reg < RFM7x_CMD_WRITE_REG ){
 8001d4c:	281f      	cmp	r0, #31
      reg |= RFM7x_CMD_WRITE_REG;
 8001d4e:	bf98      	it	ls
 8001d50:	f040 0520 	orrls.w	r5, r0, #32
   }
   RFM7x_CSN( 0 );                     // Set CSN low, init SPI transaction
 8001d54:	2000      	movs	r0, #0
      *pBuf++ = rfm7x_SPI_RW( 0 );  // read one byte from RFM7x
   }
   RFM7x_CSN( 1 );                   // Set CSN high again
}

void rfm7x_buffer_write( unsigned char reg,  const unsigned char *pBuf,  unsigned char length  ){
 8001d56:	460c      	mov	r4, r1
 8001d58:	4616      	mov	r6, r2
   unsigned char i;
   if( reg < RFM7x_CMD_WRITE_REG ){
      reg |= RFM7x_CMD_WRITE_REG;
   }
   RFM7x_CSN( 0 );                     // Set CSN low, init SPI transaction
 8001d5a:	f000 f97f 	bl	800205c <RFM7x_CSN>
   (void)rfm7x_SPI_RW( reg );         // Select register to write tio write
 8001d5e:	4628      	mov	r0, r5
 8001d60:	f000 f988 	bl	8002074 <rfm7x_SPI_RW>
 8001d64:	19a5      	adds	r5, r4, r6
   for( i = 0; i < length; i++ ){      // write all bytes in buffer(*pBuf)
 8001d66:	42ac      	cmp	r4, r5
 8001d68:	d004      	beq.n	8001d74 <rfm7x_buffer_write+0x2c>
      (void)rfm7x_SPI_RW( *pBuf++ );  // write one byte
 8001d6a:	f814 0b01 	ldrb.w	r0, [r4], #1
 8001d6e:	f000 f981 	bl	8002074 <rfm7x_SPI_RW>
 8001d72:	e7f8      	b.n	8001d66 <rfm7x_buffer_write+0x1e>
   }
   RFM7x_CSN( 1 );                     // Set CSN high again
 8001d74:	2001      	movs	r0, #1
}
 8001d76:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   RFM7x_CSN( 0 );                     // Set CSN low, init SPI transaction
   (void)rfm7x_SPI_RW( reg );         // Select register to write tio write
   for( i = 0; i < length; i++ ){      // write all bytes in buffer(*pBuf)
      (void)rfm7x_SPI_RW( *pBuf++ );  // write one byte
   }
   RFM7x_CSN( 1 );                     // Set CSN high again
 8001d7a:	f000 b96f 	b.w	800205c <RFM7x_CSN>
	...

08001d80 <rfm7x_bank>:
}

unsigned char st;
void rfm7x_bank( unsigned char b ){
 8001d80:	b510      	push	{r4, lr}
 8001d82:	4604      	mov	r4, r0
   st = (unsigned char)( 0x80 & rfm7x_register_read( RFM7x_REG_STATUS ) );
 8001d84:	2007      	movs	r0, #7
 8001d86:	f7ff ffb6 	bl	8001cf6 <rfm7x_register_read>
 8001d8a:	4b08      	ldr	r3, [pc, #32]	; (8001dac <rfm7x_bank+0x2c>)
 8001d8c:	f020 007f 	bic.w	r0, r0, #127	; 0x7f
 8001d90:	b2c0      	uxtb	r0, r0
 8001d92:	7018      	strb	r0, [r3, #0]
   if(( st &&( b == 0 )) || (( st == 0 ) && b )){
 8001d94:	b108      	cbz	r0, 8001d9a <rfm7x_bank+0x1a>
 8001d96:	b10c      	cbz	r4, 8001d9c <rfm7x_bank+0x1c>
 8001d98:	bd10      	pop	{r4, pc}
 8001d9a:	b12c      	cbz	r4, 8001da8 <rfm7x_bank+0x28>
      rfm7x_register_write( RFM7x_CMD_ACTIVATE, 0x53 );
   }
}
 8001d9c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

unsigned char st;
void rfm7x_bank( unsigned char b ){
   st = (unsigned char)( 0x80 & rfm7x_register_read( RFM7x_REG_STATUS ) );
   if(( st &&( b == 0 )) || (( st == 0 ) && b )){
      rfm7x_register_write( RFM7x_CMD_ACTIVATE, 0x53 );
 8001da0:	2153      	movs	r1, #83	; 0x53
 8001da2:	2050      	movs	r0, #80	; 0x50
 8001da4:	f7ff bf92 	b.w	8001ccc <rfm7x_register_write>
 8001da8:	bd10      	pop	{r4, pc}
 8001daa:	bf00      	nop
 8001dac:	2000011d 	.word	0x2000011d

08001db0 <rfm7x_init_bank1>:

   // initialize bank1 like in the example code.
   // don't ask why, just do it
volatile byte module_type = RFM_UNKNOWN;

void rfm7x_init_bank1( void ){
 8001db0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   unsigned char i, j;
   unsigned char WriteArr[ 12 ];

   unsigned long * Bank1_Reg0_13 = (unsigned long *)RFM70_Bank1_Reg0_13; //default
   if(module_type == RFM73) Bank1_Reg0_13 = (unsigned long *)RFM73_Bank1_Reg0_13;
 8001db2:	4b32      	ldr	r3, [pc, #200]	; (8001e7c <rfm7x_init_bank1+0xcc>)
 8001db4:	4a32      	ldr	r2, [pc, #200]	; (8001e80 <rfm7x_init_bank1+0xd0>)
 8001db6:	781d      	ldrb	r5, [r3, #0]
 8001db8:	4b32      	ldr	r3, [pc, #200]	; (8001e84 <rfm7x_init_bank1+0xd4>)

   rfm7x_bank( 1 );
 8001dba:	2001      	movs	r0, #1
void rfm7x_init_bank1( void ){
   unsigned char i, j;
   unsigned char WriteArr[ 12 ];

   unsigned long * Bank1_Reg0_13 = (unsigned long *)RFM70_Bank1_Reg0_13; //default
   if(module_type == RFM73) Bank1_Reg0_13 = (unsigned long *)RFM73_Bank1_Reg0_13;
 8001dbc:	2d02      	cmp	r5, #2
 8001dbe:	bf14      	ite	ne
 8001dc0:	4615      	movne	r5, r2
 8001dc2:	461d      	moveq	r5, r3

   rfm7x_bank( 1 );
 8001dc4:	f7ff ffdc 	bl	8001d80 <rfm7x_bank>
 8001dc8:	2400      	movs	r4, #0

   for( i = 0; i <= 8; i++ ){ //reverse!
      for( j = 0; j < 4; j++ ){
         WriteArr[ j ] = (unsigned char )( (Bank1_Reg0_13[i]>>(unsigned char)(8*j) )&0xff );
 8001dca:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
      }
      rfm7x_buffer_write( i,WriteArr, 4 );
 8001dce:	b2e0      	uxtb	r0, r4

   rfm7x_bank( 1 );

   for( i = 0; i <= 8; i++ ){ //reverse!
      for( j = 0; j < 4; j++ ){
         WriteArr[ j ] = (unsigned char )( (Bank1_Reg0_13[i]>>(unsigned char)(8*j) )&0xff );
 8001dd0:	0a1a      	lsrs	r2, r3, #8
 8001dd2:	f88d 2005 	strb.w	r2, [sp, #5]
 8001dd6:	0c1a      	lsrs	r2, r3, #16
 8001dd8:	f88d 2006 	strb.w	r2, [sp, #6]
      }
      rfm7x_buffer_write( i,WriteArr, 4 );
 8001ddc:	2204      	movs	r2, #4

   rfm7x_bank( 1 );

   for( i = 0; i <= 8; i++ ){ //reverse!
      for( j = 0; j < 4; j++ ){
         WriteArr[ j ] = (unsigned char )( (Bank1_Reg0_13[i]>>(unsigned char)(8*j) )&0xff );
 8001dde:	f88d 3004 	strb.w	r3, [sp, #4]
      }
      rfm7x_buffer_write( i,WriteArr, 4 );
 8001de2:	eb0d 0102 	add.w	r1, sp, r2

   rfm7x_bank( 1 );

   for( i = 0; i <= 8; i++ ){ //reverse!
      for( j = 0; j < 4; j++ ){
         WriteArr[ j ] = (unsigned char )( (Bank1_Reg0_13[i]>>(unsigned char)(8*j) )&0xff );
 8001de6:	0e1b      	lsrs	r3, r3, #24
 8001de8:	3401      	adds	r4, #1
 8001dea:	f88d 3007 	strb.w	r3, [sp, #7]
      }
      rfm7x_buffer_write( i,WriteArr, 4 );
 8001dee:	f7ff ffab 	bl	8001d48 <rfm7x_buffer_write>
   unsigned long * Bank1_Reg0_13 = (unsigned long *)RFM70_Bank1_Reg0_13; //default
   if(module_type == RFM73) Bank1_Reg0_13 = (unsigned long *)RFM73_Bank1_Reg0_13;

   rfm7x_bank( 1 );

   for( i = 0; i <= 8; i++ ){ //reverse!
 8001df2:	2c09      	cmp	r4, #9
 8001df4:	d1e9      	bne.n	8001dca <rfm7x_init_bank1+0x1a>
 8001df6:	f105 0620 	add.w	r6, r5, #32
      rfm7x_buffer_write( i,WriteArr, 4 );
   }

   for( i = 9; i <= 13; i++ ){
      for( j = 0; j < 4; j++ ){
         WriteArr[ j ]= (unsigned char )((Bank1_Reg0_13[i]>>(unsigned char)(8*(3-j)) )&0xff);
 8001dfa:	f856 3f04 	ldr.w	r3, [r6, #4]!
      }
      rfm7x_buffer_write( i, WriteArr, 4 );
 8001dfe:	4620      	mov	r0, r4
      rfm7x_buffer_write( i,WriteArr, 4 );
   }

   for( i = 9; i <= 13; i++ ){
      for( j = 0; j < 4; j++ ){
         WriteArr[ j ]= (unsigned char )((Bank1_Reg0_13[i]>>(unsigned char)(8*(3-j)) )&0xff);
 8001e00:	0e1a      	lsrs	r2, r3, #24
 8001e02:	f88d 2004 	strb.w	r2, [sp, #4]
 8001e06:	0c1a      	lsrs	r2, r3, #16
 8001e08:	f88d 2005 	strb.w	r2, [sp, #5]
 8001e0c:	0a1a      	lsrs	r2, r3, #8
 8001e0e:	f88d 2006 	strb.w	r2, [sp, #6]
         WriteArr[ j ] = (unsigned char )( (Bank1_Reg0_13[i]>>(unsigned char)(8*j) )&0xff );
      }
      rfm7x_buffer_write( i,WriteArr, 4 );
   }

   for( i = 9; i <= 13; i++ ){
 8001e12:	3401      	adds	r4, #1
      for( j = 0; j < 4; j++ ){
         WriteArr[ j ]= (unsigned char )((Bank1_Reg0_13[i]>>(unsigned char)(8*(3-j)) )&0xff);
      }
      rfm7x_buffer_write( i, WriteArr, 4 );
 8001e14:	2204      	movs	r2, #4
 8001e16:	eb0d 0102 	add.w	r1, sp, r2
         WriteArr[ j ] = (unsigned char )( (Bank1_Reg0_13[i]>>(unsigned char)(8*j) )&0xff );
      }
      rfm7x_buffer_write( i,WriteArr, 4 );
   }

   for( i = 9; i <= 13; i++ ){
 8001e1a:	b2e4      	uxtb	r4, r4
      for( j = 0; j < 4; j++ ){
         WriteArr[ j ]= (unsigned char )((Bank1_Reg0_13[i]>>(unsigned char)(8*(3-j)) )&0xff);
 8001e1c:	f88d 3007 	strb.w	r3, [sp, #7]
      }
      rfm7x_buffer_write( i, WriteArr, 4 );
 8001e20:	f7ff ff92 	bl	8001d48 <rfm7x_buffer_write>
         WriteArr[ j ] = (unsigned char )( (Bank1_Reg0_13[i]>>(unsigned char)(8*j) )&0xff );
      }
      rfm7x_buffer_write( i,WriteArr, 4 );
   }

   for( i = 9; i <= 13; i++ ){
 8001e24:	2c0e      	cmp	r4, #14
 8001e26:	d1e8      	bne.n	8001dfa <rfm7x_init_bank1+0x4a>
         WriteArr[ j ]= (unsigned char )((Bank1_Reg0_13[i]>>(unsigned char)(8*(3-j)) )&0xff);
      }
      rfm7x_buffer_write( i, WriteArr, 4 );
   }

   rfm7x_buffer_write( 14, Bank1_Reg14, 11 );
 8001e28:	4620      	mov	r0, r4
 8001e2a:	220b      	movs	r2, #11
 8001e2c:	4916      	ldr	r1, [pc, #88]	; (8001e88 <rfm7x_init_bank1+0xd8>)
 8001e2e:	f7ff ff8b 	bl	8001d48 <rfm7x_buffer_write>

   //toggle REG4<25,26>
   for(j=0;j<4;j++){
      WriteArr[ j ]= (unsigned char)((Bank1_Reg0_13[4]>>(unsigned char)(8*j))&0xff);
 8001e32:	692b      	ldr	r3, [r5, #16]
 8001e34:	0a1a      	lsrs	r2, r3, #8
 8001e36:	f88d 2005 	strb.w	r2, [sp, #5]
 8001e3a:	0c1a      	lsrs	r2, r3, #16
 8001e3c:	f88d 2006 	strb.w	r2, [sp, #6]
 8001e40:	0e1a      	lsrs	r2, r3, #24
 8001e42:	f88d 2007 	strb.w	r2, [sp, #7]
   }

   WriteArr[ 0 ] = (unsigned char )(WriteArr[ 0 ] | 0x06);
   rfm7x_buffer_write( 4, WriteArr, 4);
 8001e46:	2204      	movs	r2, #4
 8001e48:	eb0d 0102 	add.w	r1, sp, r2
   //toggle REG4<25,26>
   for(j=0;j<4;j++){
      WriteArr[ j ]= (unsigned char)((Bank1_Reg0_13[4]>>(unsigned char)(8*j))&0xff);
   }

   WriteArr[ 0 ] = (unsigned char )(WriteArr[ 0 ] | 0x06);
 8001e4c:	f043 0306 	orr.w	r3, r3, #6
   rfm7x_buffer_write( 4, WriteArr, 4);
 8001e50:	4610      	mov	r0, r2
   //toggle REG4<25,26>
   for(j=0;j<4;j++){
      WriteArr[ j ]= (unsigned char)((Bank1_Reg0_13[4]>>(unsigned char)(8*j))&0xff);
   }

   WriteArr[ 0 ] = (unsigned char )(WriteArr[ 0 ] | 0x06);
 8001e52:	f88d 3004 	strb.w	r3, [sp, #4]
   rfm7x_buffer_write( 4, WriteArr, 4);
 8001e56:	f7ff ff77 	bl	8001d48 <rfm7x_buffer_write>

   WriteArr[ 0 ] = (unsigned char )(WriteArr[ 0 ] & 0xf9);
 8001e5a:	f89d 3004 	ldrb.w	r3, [sp, #4]
   rfm7x_buffer_write( 4, WriteArr,4);
 8001e5e:	2204      	movs	r2, #4
   }

   WriteArr[ 0 ] = (unsigned char )(WriteArr[ 0 ] | 0x06);
   rfm7x_buffer_write( 4, WriteArr, 4);

   WriteArr[ 0 ] = (unsigned char )(WriteArr[ 0 ] & 0xf9);
 8001e60:	f023 0306 	bic.w	r3, r3, #6
   rfm7x_buffer_write( 4, WriteArr,4);
 8001e64:	4610      	mov	r0, r2
 8001e66:	eb0d 0102 	add.w	r1, sp, r2
   }

   WriteArr[ 0 ] = (unsigned char )(WriteArr[ 0 ] | 0x06);
   rfm7x_buffer_write( 4, WriteArr, 4);

   WriteArr[ 0 ] = (unsigned char )(WriteArr[ 0 ] & 0xf9);
 8001e6a:	f88d 3004 	strb.w	r3, [sp, #4]
   rfm7x_buffer_write( 4, WriteArr,4);
 8001e6e:	f7ff ff6b 	bl	8001d48 <rfm7x_buffer_write>

   rfm7x_bank( 0 );
 8001e72:	2000      	movs	r0, #0
 8001e74:	f7ff ff84 	bl	8001d80 <rfm7x_bank>
}
 8001e78:	b004      	add	sp, #16
 8001e7a:	bd70      	pop	{r4, r5, r6, pc}
 8001e7c:	20000024 	.word	0x20000024
 8001e80:	08002130 	.word	0x08002130
 8001e84:	0800217c 	.word	0x0800217c
 8001e88:	08002122 	.word	0x08002122

08001e8c <rfm7x_is_present>:
  unsigned char st1;
  st1 = rfm7x_register_read( RFM7x_REG_STATUS );
  rfm7x_register_write( RFM7x_REG_STATUS, st1 | 0b01110000 );
}

unsigned char rfm7x_is_present( void ){
 8001e8c:	b538      	push	{r3, r4, r5, lr}
  unsigned char st1, st2;
  st1 = rfm7x_register_read( RFM7x_REG_STATUS );
 8001e8e:	2007      	movs	r0, #7
 8001e90:	f7ff ff31 	bl	8001cf6 <rfm7x_register_read>
  rfm7x_register_write( RFM7x_CMD_ACTIVATE, 0x53 );
 8001e94:	2153      	movs	r1, #83	; 0x53
  rfm7x_register_write( RFM7x_REG_STATUS, st1 | 0b01110000 );
}

unsigned char rfm7x_is_present( void ){
  unsigned char st1, st2;
  st1 = rfm7x_register_read( RFM7x_REG_STATUS );
 8001e96:	4605      	mov	r5, r0
  rfm7x_register_write( RFM7x_CMD_ACTIVATE, 0x53 );
 8001e98:	2050      	movs	r0, #80	; 0x50
 8001e9a:	f7ff ff17 	bl	8001ccc <rfm7x_register_write>
  st2 = rfm7x_register_read( RFM7x_REG_STATUS );
 8001e9e:	2007      	movs	r0, #7
 8001ea0:	f7ff ff29 	bl	8001cf6 <rfm7x_register_read>
 8001ea4:	4604      	mov	r4, r0
  rfm7x_register_write( RFM7x_CMD_ACTIVATE, 0x53 );
 8001ea6:	2153      	movs	r1, #83	; 0x53
 8001ea8:	2050      	movs	r0, #80	; 0x50
 8001eaa:	f7ff ff0f 	bl	8001ccc <rfm7x_register_write>
  return (unsigned char )(( st1 ^ st2 ) == 0x80);
 8001eae:	ea85 0004 	eor.w	r0, r5, r4
 8001eb2:	b2c0      	uxtb	r0, r0
}
 8001eb4:	f1a0 0380 	sub.w	r3, r0, #128	; 0x80
 8001eb8:	4258      	negs	r0, r3
 8001eba:	4158      	adcs	r0, r3
 8001ebc:	bd38      	pop	{r3, r4, r5, pc}
	...

08001ec0 <rfm7x_mode_receive>:


volatile byte rfm7x_mode;

void rfm7x_mode_receive( void )
{
 8001ec0:	b508      	push	{r3, lr}
  unsigned char value;

  rfm7x_mode = RFM7x_MODE_RECEIVE;
 8001ec2:	4b0f      	ldr	r3, [pc, #60]	; (8001f00 <rfm7x_mode_receive+0x40>)
 8001ec4:	2202      	movs	r2, #2

  // flush receive queue
  rfm7x_register_write( RFM7x_CMD_FLUSH_RX, 0 );
 8001ec6:	2100      	movs	r1, #0
 8001ec8:	20e2      	movs	r0, #226	; 0xe2

void rfm7x_mode_receive( void )
{
  unsigned char value;

  rfm7x_mode = RFM7x_MODE_RECEIVE;
 8001eca:	701a      	strb	r2, [r3, #0]

  // flush receive queue
  rfm7x_register_write( RFM7x_CMD_FLUSH_RX, 0 );
 8001ecc:	f7ff fefe 	bl	8001ccc <rfm7x_register_write>

  // clear interrupt status
  value = rfm7x_register_read( RFM7x_REG_STATUS );
 8001ed0:	2007      	movs	r0, #7
 8001ed2:	f7ff ff10 	bl	8001cf6 <rfm7x_register_read>
  rfm7x_register_write( RFM7x_REG_STATUS ,value );
 8001ed6:	4601      	mov	r1, r0
 8001ed8:	2007      	movs	r0, #7
 8001eda:	f7ff fef7 	bl	8001ccc <rfm7x_register_write>

  // switch to receive mode
  RFM7x_CE( 0 );
 8001ede:	2000      	movs	r0, #0
 8001ee0:	f000 f8b4 	bl	800204c <RFM7x_CE>
  value = rfm7x_register_read( RFM7x_REG_CONFIG );
 8001ee4:	2000      	movs	r0, #0
 8001ee6:	f7ff ff06 	bl	8001cf6 <rfm7x_register_read>
  value |= 0x01; // set RX bit
  value |= 0x02; // set PWR_UP bit
  rfm7x_register_write( RFM7x_REG_CONFIG, value );
 8001eea:	f040 0103 	orr.w	r1, r0, #3
 8001eee:	b2c9      	uxtb	r1, r1
 8001ef0:	2000      	movs	r0, #0
 8001ef2:	f7ff feeb 	bl	8001ccc <rfm7x_register_write>
  RFM7x_CE( 1 );
}
 8001ef6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  RFM7x_CE( 0 );
  value = rfm7x_register_read( RFM7x_REG_CONFIG );
  value |= 0x01; // set RX bit
  value |= 0x02; // set PWR_UP bit
  rfm7x_register_write( RFM7x_REG_CONFIG, value );
  RFM7x_CE( 1 );
 8001efa:	2001      	movs	r0, #1
 8001efc:	f000 b8a6 	b.w	800204c <RFM7x_CE>
 8001f00:	2000011c 	.word	0x2000011c

08001f04 <rfm7x_channel>:
}

volatile byte rfm7x_current_channel;
void rfm7x_channel( unsigned char ch ){
  // MSB must be 0
  rfm7x_current_channel = ch;
 8001f04:	4b03      	ldr	r3, [pc, #12]	; (8001f14 <rfm7x_channel+0x10>)
  rfm7x_register_write( RFM7x_REG_RF_CH, (unsigned char )(ch & 0x7E) );
 8001f06:	f000 017e 	and.w	r1, r0, #126	; 0x7e
}

volatile byte rfm7x_current_channel;
void rfm7x_channel( unsigned char ch ){
  // MSB must be 0
  rfm7x_current_channel = ch;
 8001f0a:	7018      	strb	r0, [r3, #0]
  rfm7x_register_write( RFM7x_REG_RF_CH, (unsigned char )(ch & 0x7E) );
 8001f0c:	2005      	movs	r0, #5
 8001f0e:	f7ff bedd 	b.w	8001ccc <rfm7x_register_write>
 8001f12:	bf00      	nop
 8001f14:	2000011e 	.word	0x2000011e

08001f18 <rfm7x_receive_fifo_empty>:
  unsigned char s;
  s = rfm7x_register_read( RFM7x_REG_FIFO_STATUS );
  return (unsigned char )( (unsigned char) (s & FIFO_STATUS_TX_FULL ) != 0);
}

unsigned char rfm7x_receive_fifo_empty( void ){
 8001f18:	b508      	push	{r3, lr}
  unsigned char s;
  s = rfm7x_register_read( RFM7x_REG_FIFO_STATUS );
 8001f1a:	2017      	movs	r0, #23
 8001f1c:	f7ff feeb 	bl	8001cf6 <rfm7x_register_read>
  return (unsigned char )(( s & FIFO_STATUS_RX_EMPTY ) != 0);
}
 8001f20:	f000 0001 	and.w	r0, r0, #1
 8001f24:	bd08      	pop	{r3, pc}

08001f26 <rfm7x_receive_address_p0>:

void rfm7x_receive_address_p0( const unsigned char address[ 5 ] ){
   rfm7x_buffer_write( RFM7x_REG_RX_ADDR_P0, address, 5 );
 8001f26:	4601      	mov	r1, r0
 8001f28:	2205      	movs	r2, #5
 8001f2a:	200a      	movs	r0, #10
 8001f2c:	f7ff bf0c 	b.w	8001d48 <rfm7x_buffer_write>

08001f30 <rfm7x_receive_address_p1>:
}

void rfm7x_receive_address_p1( const unsigned char address[ 5 ] ){
   rfm7x_buffer_write( RFM7x_REG_RX_ADDR_P1, address, 5 );
 8001f30:	4601      	mov	r1, r0
 8001f32:	2205      	movs	r2, #5
 8001f34:	200b      	movs	r0, #11
 8001f36:	f7ff bf07 	b.w	8001d48 <rfm7x_buffer_write>

08001f3a <rfm7x_transmit_address>:
void rfm7x_receive_address_pn( unsigned char channel, unsigned char address ){
   rfm7x_register_write( (unsigned char )(RFM7x_REG_RX_ADDR_P0 + channel), address );
}

void rfm7x_transmit_address( const unsigned char *address ){
   rfm7x_buffer_write( RFM7x_REG_TX_ADDR, address, 5 );
 8001f3a:	4601      	mov	r1, r0
 8001f3c:	2205      	movs	r2, #5
 8001f3e:	2010      	movs	r0, #16
 8001f40:	f7ff bf02 	b.w	8001d48 <rfm7x_buffer_write>

08001f44 <rfm7x_channel_payload_size>:
   val |= ( level << 1 );
   rfm7x_register_write( RFM7x_REG_RF_SETUP, val );
   RFM7x_CE( 1 );
}

void rfm7x_channel_payload_size( unsigned char channel, unsigned char size ){
 8001f44:	2920      	cmp	r1, #32
 8001f46:	bf28      	it	cs
 8001f48:	2120      	movcs	r1, #32
 8001f4a:	b538      	push	{r3, r4, r5, lr}
 8001f4c:	4605      	mov	r5, r0
 8001f4e:	460c      	mov	r4, r1
   unsigned char val;
   if( size > 32 ){
      size = 32;
   }
   val = rfm7x_register_read( RFM7x_REG_DYNPD );
 8001f50:	201c      	movs	r0, #28
 8001f52:	f7ff fed0 	bl	8001cf6 <rfm7x_register_read>
 8001f56:	2101      	movs	r1, #1
   if( size == 0 ){
      val |= 1 << channel;
 8001f58:	40a9      	lsls	r1, r5
   unsigned char val;
   if( size > 32 ){
      size = 32;
   }
   val = rfm7x_register_read( RFM7x_REG_DYNPD );
   if( size == 0 ){
 8001f5a:	b90c      	cbnz	r4, 8001f60 <rfm7x_channel_payload_size+0x1c>
      val |= 1 << channel;
 8001f5c:	4301      	orrs	r1, r0
 8001f5e:	e001      	b.n	8001f64 <rfm7x_channel_payload_size+0x20>
   } else {
      val &= ~ ( 1 << channel );
 8001f60:	ea20 0101 	bic.w	r1, r0, r1
 8001f64:	b2c9      	uxtb	r1, r1
   }
   rfm7x_register_write( RFM7x_REG_DYNPD, val );
 8001f66:	201c      	movs	r0, #28
 8001f68:	f7ff feb0 	bl	8001ccc <rfm7x_register_write>
   rfm7x_register_write( (unsigned char)(RFM7x_REG_RX_PW_P0 + channel), size );
 8001f6c:	f105 0011 	add.w	r0, r5, #17
 8001f70:	4621      	mov	r1, r4
}
 8001f72:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      val |= 1 << channel;
   } else {
      val &= ~ ( 1 << channel );
   }
   rfm7x_register_write( RFM7x_REG_DYNPD, val );
   rfm7x_register_write( (unsigned char)(RFM7x_REG_RX_PW_P0 + channel), size );
 8001f76:	b2c0      	uxtb	r0, r0
 8001f78:	f7ff bea8 	b.w	8001ccc <rfm7x_register_write>

08001f7c <rfm7x_receive_next_pipe>:
      length = 32;
   }
   rfm7x_buffer_write( RFM7x_CMD_W_TX_PAYLOAD_NOACK, buf, length );
}

unsigned char rfm7x_receive_next_pipe( void ){
 8001f7c:	b508      	push	{r3, lr}
   unsigned char status = rfm7x_register_read( RFM7x_REG_STATUS );
 8001f7e:	2007      	movs	r0, #7
 8001f80:	f7ff feb9 	bl	8001cf6 <rfm7x_register_read>
   return (unsigned char)(( status >> 1 ) & 0x07);
}
 8001f84:	f3c0 0042 	ubfx	r0, r0, #1, #3
 8001f88:	bd08      	pop	{r3, pc}

08001f8a <rfm7x_receive_next_length>:

unsigned char rfm7x_receive_next_length( void ){
   return rfm7x_register_read( RFM7x_CMD_R_RX_PL_WID );
 8001f8a:	2060      	movs	r0, #96	; 0x60
 8001f8c:	f7ff beb3 	b.w	8001cf6 <rfm7x_register_read>

08001f90 <rfm7x_receive>:
}

unsigned char rfm7x_receive( unsigned char * pipe, unsigned char *buf, unsigned char * length){
 8001f90:	b570      	push	{r4, r5, r6, lr}
 8001f92:	4606      	mov	r6, r0
 8001f94:	460c      	mov	r4, r1
 8001f96:	4615      	mov	r5, r2
   unsigned char p = rfm7x_receive_next_pipe();
 8001f98:	f7ff fff0 	bl	8001f7c <rfm7x_receive_next_pipe>
   if( p == 0x07 ){
 8001f9c:	2807      	cmp	r0, #7
 8001f9e:	d00a      	beq.n	8001fb6 <rfm7x_receive+0x26>
      return 0;
   }
   *pipe = p;
 8001fa0:	7030      	strb	r0, [r6, #0]
   *length = rfm7x_receive_next_length();
 8001fa2:	f7ff fff2 	bl	8001f8a <rfm7x_receive_next_length>
   rfm7x_buffer_read( RFM7x_CMD_R_RX_PAYLOAD, buf, * length );
 8001fa6:	4621      	mov	r1, r4
   unsigned char p = rfm7x_receive_next_pipe();
   if( p == 0x07 ){
      return 0;
   }
   *pipe = p;
   *length = rfm7x_receive_next_length();
 8001fa8:	4602      	mov	r2, r0
 8001faa:	7028      	strb	r0, [r5, #0]
   rfm7x_buffer_read( RFM7x_CMD_R_RX_PAYLOAD, buf, * length );
 8001fac:	2061      	movs	r0, #97	; 0x61
 8001fae:	f7ff feb3 	bl	8001d18 <rfm7x_buffer_read>
   return 1;
 8001fb2:	2001      	movs	r0, #1
 8001fb4:	bd70      	pop	{r4, r5, r6, pc}
}

unsigned char rfm7x_receive( unsigned char * pipe, unsigned char *buf, unsigned char * length){
   unsigned char p = rfm7x_receive_next_pipe();
   if( p == 0x07 ){
      return 0;
 8001fb6:	2000      	movs	r0, #0
   }
   *pipe = p;
   *length = rfm7x_receive_next_length();
   rfm7x_buffer_read( RFM7x_CMD_R_RX_PAYLOAD, buf, * length );
   return 1;
}
 8001fb8:	bd70      	pop	{r4, r5, r6, pc}
	...

08001fbc <rfm7x_init>:



void rfm7x_init( unsigned char _module_type ){
 8001fbc:	b538      	push	{r3, r4, r5, lr}
   unsigned char i;

   module_type = _module_type;
 8001fbe:	4b20      	ldr	r3, [pc, #128]	; (8002040 <rfm7x_init+0x84>)
   RFM7x_WAIT_MS( 50 );

   // write array of default init settings
   rfm7x_bank( 0 );
   for( i = 0; i < BANK0_ENTRIES; i++ ){
     rfm7x_register_write( Bank0_Reg[ i ][0], Bank0_Reg[ i ][1] );
 8001fc0:	4d20      	ldr	r5, [pc, #128]	; (8002044 <rfm7x_init+0x88>)


void rfm7x_init( unsigned char _module_type ){
   unsigned char i;

   module_type = _module_type;
 8001fc2:	7018      	strb	r0, [r3, #0]

   RFM7x_CE( 0 );
 8001fc4:	2000      	movs	r0, #0
 8001fc6:	f000 f841 	bl	800204c <RFM7x_CE>
   RFM7x_CSN( 1 );
 8001fca:	2001      	movs	r0, #1
 8001fcc:	f000 f846 	bl	800205c <RFM7x_CSN>

   // delay at least 50ms.
   // the example code says so, but why??
   RFM7x_WAIT_MS( 50 );
 8001fd0:	2032      	movs	r0, #50	; 0x32
 8001fd2:	f000 f84b 	bl	800206c <RFM7x_WAIT_MS>

   // write array of default init settings
   rfm7x_bank( 0 );
 8001fd6:	2000      	movs	r0, #0
 8001fd8:	f7ff fed2 	bl	8001d80 <rfm7x_bank>
 8001fdc:	2400      	movs	r4, #0
   for( i = 0; i < BANK0_ENTRIES; i++ ){
     rfm7x_register_write( Bank0_Reg[ i ][0], Bank0_Reg[ i ][1] );
 8001fde:	192b      	adds	r3, r5, r4
 8001fe0:	5d28      	ldrb	r0, [r5, r4]
 8001fe2:	7859      	ldrb	r1, [r3, #1]
 8001fe4:	3402      	adds	r4, #2
 8001fe6:	f7ff fe71 	bl	8001ccc <rfm7x_register_write>
   // the example code says so, but why??
   RFM7x_WAIT_MS( 50 );

   // write array of default init settings
   rfm7x_bank( 0 );
   for( i = 0; i < BANK0_ENTRIES; i++ ){
 8001fea:	2c14      	cmp	r4, #20
 8001fec:	d1f7      	bne.n	8001fde <rfm7x_init+0x22>
     rfm7x_register_write( Bank0_Reg[ i ][0], Bank0_Reg[ i ][1] );
   }

   rfm7x_receive_address_p0( rfm7x_RX0_Address );
 8001fee:	4816      	ldr	r0, [pc, #88]	; (8002048 <rfm7x_init+0x8c>)
 8001ff0:	f7ff ff99 	bl	8001f26 <rfm7x_receive_address_p0>
   rfm7x_receive_address_p1( rfm7x_RX0_Address );
 8001ff4:	4814      	ldr	r0, [pc, #80]	; (8002048 <rfm7x_init+0x8c>)
 8001ff6:	f7ff ff9b 	bl	8001f30 <rfm7x_receive_address_p1>
   rfm7x_transmit_address( rfm7x_RX0_Address );
 8001ffa:	4813      	ldr	r0, [pc, #76]	; (8002048 <rfm7x_init+0x8c>)
 8001ffc:	f7ff ff9d 	bl	8001f3a <rfm7x_transmit_address>

   // enable the extra features
   i = rfm7x_register_read(29);
 8002000:	201d      	movs	r0, #29
 8002002:	f7ff fe78 	bl	8001cf6 <rfm7x_register_read>
   if( i == 0 ){ // only when the extra features are not yet activated!
 8002006:	b918      	cbnz	r0, 8002010 <rfm7x_init+0x54>
      rfm7x_register_write( RFM7x_CMD_ACTIVATE, 0x73 );
 8002008:	2173      	movs	r1, #115	; 0x73
 800200a:	2050      	movs	r0, #80	; 0x50
 800200c:	f7ff fe5e 	bl	8001ccc <rfm7x_register_write>
   }

   // select dynamic payload length data pipe5\4\3\2\1\0
   rfm7x_register_write( 28, 0x3F );
 8002010:	213f      	movs	r1, #63	; 0x3f
 8002012:	201c      	movs	r0, #28
 8002014:	f7ff fe5a 	bl	8001ccc <rfm7x_register_write>

   // select Dynamic Payload Length, Payload with ACK, W_TX_PAYLOAD_NOACK
   rfm7x_register_write( 29, 0x07 );
 8002018:	2107      	movs	r1, #7
 800201a:	201d      	movs	r0, #29
 800201c:	f7ff fe56 	bl	8001ccc <rfm7x_register_write>

   // dynamic payload sizing on channels 0 and 1
   rfm7x_channel_payload_size( 0, 0 );
 8002020:	2100      	movs	r1, #0
 8002022:	4608      	mov	r0, r1
 8002024:	f7ff ff8e 	bl	8001f44 <rfm7x_channel_payload_size>
   rfm7x_channel_payload_size( 1, 0 );
 8002028:	2001      	movs	r0, #1
 800202a:	2100      	movs	r1, #0
 800202c:	f7ff ff8a 	bl	8001f44 <rfm7x_channel_payload_size>

   rfm7x_init_bank1();
 8002030:	f7ff febe 	bl	8001db0 <rfm7x_init_bank1>
   RFM7x_WAIT_MS( 50 );
   //rfm7x_mode_receive();
}
 8002034:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   // dynamic payload sizing on channels 0 and 1
   rfm7x_channel_payload_size( 0, 0 );
   rfm7x_channel_payload_size( 1, 0 );

   rfm7x_init_bank1();
   RFM7x_WAIT_MS( 50 );
 8002038:	2032      	movs	r0, #50	; 0x32
 800203a:	f000 b817 	b.w	800206c <RFM7x_WAIT_MS>
 800203e:	bf00      	nop
 8002040:	20000024 	.word	0x20000024
 8002044:	08002168 	.word	0x08002168
 8002048:	0800211d 	.word	0x0800211d

0800204c <RFM7x_CE>:
{
  #if defined(MC9S08QE4)|| defined(MC9S12NE64CPV) || defined(MC9S08QE16CLC) || defined(MC9S08QE32)
	   rf_ce_PutVal(v);
  #endif
  #if defined(STM32L152RET)
     HAL_GPIO_WritePin(rf_ce_GPIO_Port, rf_ce_Pin, _value);
 800204c:	4602      	mov	r2, r0
 800204e:	2140      	movs	r1, #64	; 0x40
 8002050:	4801      	ldr	r0, [pc, #4]	; (8002058 <RFM7x_CE+0xc>)
 8002052:	f7fe bc5d 	b.w	8000910 <HAL_GPIO_WritePin>
 8002056:	bf00      	nop
 8002058:	40020800 	.word	0x40020800

0800205c <RFM7x_CSN>:
{
  #if defined(MC9S08QE4)|| defined(MC9S12NE64CPV) || defined(MC9S08QE16CLC) || defined(MC9S08QE32)
	   rf_nss_PutVal(_value);
  #endif
  #if defined(STM32L152RET)
      HAL_GPIO_WritePin(rf_nss_GPIO_Port, rf_nss_Pin, _value);
 800205c:	4602      	mov	r2, r0
 800205e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8002062:	4801      	ldr	r0, [pc, #4]	; (8002068 <RFM7x_CSN+0xc>)
 8002064:	f7fe bc54 	b.w	8000910 <HAL_GPIO_WritePin>
 8002068:	40020400 	.word	0x40020400

0800206c <RFM7x_WAIT_MS>:
{
  #if defined(MC9S08QE4)|| defined(MC9S12NE64CPV) || defined(MC9S08QE16CLC) || defined(MC9S08QE32)
      Cpu_Delay100US(10 * ms);
  #endif
  #if defined(STM32L152RET)
     HAL_Delay(10*ms);
 800206c:	230a      	movs	r3, #10
 800206e:	4358      	muls	r0, r3
 8002070:	f7fe baf0 	b.w	8000654 <HAL_Delay>

08002074 <rfm7x_SPI_RW>:
  #endif
}


unsigned char rfm7x_SPI_RW( unsigned char value )
{
 8002074:	b51f      	push	{r0, r1, r2, r3, r4, lr}
      uint8_t  RXdata[2];
      uint8_t  TXdata[2];

      TXdata[0] = value;

      HAL_SPI_TransmitReceive(&hspi2, TXdata, RXdata, 1, 0);
 8002076:	2300      	movs	r3, #0
  #if defined(STM32L152RET)

      uint8_t  RXdata[2];
      uint8_t  TXdata[2];

      TXdata[0] = value;
 8002078:	f88d 000c 	strb.w	r0, [sp, #12]

      HAL_SPI_TransmitReceive(&hspi2, TXdata, RXdata, 1, 0);
 800207c:	9300      	str	r3, [sp, #0]
 800207e:	aa02      	add	r2, sp, #8
 8002080:	2301      	movs	r3, #1
 8002082:	a903      	add	r1, sp, #12
 8002084:	4803      	ldr	r0, [pc, #12]	; (8002094 <rfm7x_SPI_RW+0x20>)
 8002086:	f7ff f954 	bl	8001332 <HAL_SPI_TransmitReceive>

      return RXdata[0];
  #endif
}
 800208a:	f89d 0008 	ldrb.w	r0, [sp, #8]
 800208e:	b005      	add	sp, #20
 8002090:	f85d fb04 	ldr.w	pc, [sp], #4
 8002094:	20000048 	.word	0x20000048

08002098 <__libc_init_array>:
 8002098:	4b0e      	ldr	r3, [pc, #56]	; (80020d4 <__libc_init_array+0x3c>)
 800209a:	b570      	push	{r4, r5, r6, lr}
 800209c:	461e      	mov	r6, r3
 800209e:	4c0e      	ldr	r4, [pc, #56]	; (80020d8 <__libc_init_array+0x40>)
 80020a0:	2500      	movs	r5, #0
 80020a2:	1ae4      	subs	r4, r4, r3
 80020a4:	10a4      	asrs	r4, r4, #2
 80020a6:	42a5      	cmp	r5, r4
 80020a8:	d004      	beq.n	80020b4 <__libc_init_array+0x1c>
 80020aa:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80020ae:	4798      	blx	r3
 80020b0:	3501      	adds	r5, #1
 80020b2:	e7f8      	b.n	80020a6 <__libc_init_array+0xe>
 80020b4:	f000 f816 	bl	80020e4 <_init>
 80020b8:	4b08      	ldr	r3, [pc, #32]	; (80020dc <__libc_init_array+0x44>)
 80020ba:	4c09      	ldr	r4, [pc, #36]	; (80020e0 <__libc_init_array+0x48>)
 80020bc:	461e      	mov	r6, r3
 80020be:	1ae4      	subs	r4, r4, r3
 80020c0:	10a4      	asrs	r4, r4, #2
 80020c2:	2500      	movs	r5, #0
 80020c4:	42a5      	cmp	r5, r4
 80020c6:	d004      	beq.n	80020d2 <__libc_init_array+0x3a>
 80020c8:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80020cc:	4798      	blx	r3
 80020ce:	3501      	adds	r5, #1
 80020d0:	e7f8      	b.n	80020c4 <__libc_init_array+0x2c>
 80020d2:	bd70      	pop	{r4, r5, r6, pc}
 80020d4:	080021b4 	.word	0x080021b4
 80020d8:	080021b4 	.word	0x080021b4
 80020dc:	080021b4 	.word	0x080021b4
 80020e0:	080021b8 	.word	0x080021b8

080020e4 <_init>:
 80020e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80020e6:	bf00      	nop
 80020e8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80020ea:	bc08      	pop	{r3}
 80020ec:	469e      	mov	lr, r3
 80020ee:	4770      	bx	lr

080020f0 <_fini>:
 80020f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80020f2:	bf00      	nop
 80020f4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80020f6:	bc08      	pop	{r3}
 80020f8:	469e      	mov	lr, r3
 80020fa:	4770      	bx	lr
